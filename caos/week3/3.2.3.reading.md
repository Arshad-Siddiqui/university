# üìí Notes: Understanding I/O Device Integration ‚Äì Disk Access in Action

## 1. I/O Devices and the Bus

* **I/O devices**: Graphics cards, USB controllers, keyboards, disks, etc.
* These connect to the **CPU and main memory** via an **I/O bus**.

  * Unlike system/memory buses (tightly tied to the CPU), I/O buses are **CPU-agnostic** so they can support third-party devices.
* Example devices on the I/O bus:

  * **USB Controller** ‚Üí gateway for USB devices (e.g., disks, printers, mice, keyboards).
  * **Graphics Adapter (GPU)** ‚Üí handles rendering, relieving CPU load.
  * **Host Bus Adapter (HBA)** ‚Üí connects disks (via SCSI/SATA). SCSI supports multiple disks; SATA usually only one.

---

## 2. Memory-Mapped I/O

* **Definition**: Reserves a portion of the CPU‚Äôs address space for device communication.
* Each device has one or more **I/O ports** (special addresses).
* CPU interacts with devices by reading/writing to these addresses, just like regular memory.

**Example (Disk Controller):**

* Suppose mapped to port `0xA0`.

1. CPU writes a **command word** (e.g., ‚Äústart read, interrupt me when done‚Äù).
2. CPU writes the **logical block number** (which disk block to read).
3. CPU writes the **destination memory address**.

‚û°Ô∏è This makes devices look like part of memory ‚Äî simplifying CPU‚Äìdevice interaction.

---

## 3. Disk Access Process

### Step A: CPU Initiation

* CPU issues commands to the disk controller via memory-mapped I/O.
* Instead of waiting idly, the CPU continues executing other instructions.

### Step B: Direct Memory Access (DMA)

* The **disk controller** handles the actual data transfer:

  * Translates logical block ‚Üí sector address.
  * Reads data and transfers it directly into **main memory**.
* This bypasses the CPU, saving millions of wasted instruction cycles.
* Transfer is called a **DMA transfer**.

### Step C: Interrupts

* Once the transfer is done:

  * Disk controller sends an **interrupt** to the CPU.
  * CPU pauses its work, jumps to an OS interrupt handler, records completion, then resumes.
* This allows **asynchronous** I/O (CPU and disk working concurrently).

---

## 4. Trade-offs of Memory-Mapped I/O

‚úÖ **Advantages**

* Unified address space (same instructions for memory and device access).
* Simpler CPU design (no special I/O instructions).
* Flexible device communication.

‚ö†Ô∏è **Disadvantages**

* Consumes part of CPU‚Äôs address space.
* Risk of bottleneck if many devices compete for bus access.
* Complexity in ensuring secure isolation between memory and devices.

---

## 5. Why It Matters

* **USB controllers, GPUs, and HBAs** all rely on this bus + memory-mapping to work efficiently.
* Without DMA + interrupts, CPUs would spend most cycles *waiting* for I/O.
* Modern systems layer in **PCIe** (point-to-point links) for higher bandwidth vs. old PCI shared bus.

---

## Key Terms

* **Memory-Mapped I/O** ‚Üí Devices exposed as memory addresses.
* **DMA (Direct Memory Access)** ‚Üí Devices transfer data directly into memory without CPU intervention.
* **Interrupt** ‚Üí Hardware signal that notifies CPU when I/O is complete.
* **Host Bus Adapter (HBA)** ‚Üí Hardware that connects disks to system bus (SCSI/SATA).

---

‚ú® **Big Idea**: Memory-mapped I/O + DMA + interrupts = efficient, asynchronous device communication that keeps CPUs productive while I/O devices work in parallel.