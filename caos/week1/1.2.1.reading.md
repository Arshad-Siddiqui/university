## 🔧 2.1 Initial Observations: What Is a Computer System?

* **Hardware** includes: chips, circuit boards, connectors, **and peripherals** like a keyboard or mouse.

* **Characteristics**:

  * Operates with **binary** (1s and 0s).
  * Speed bottlenecks arise from how fast circuits can switch or move data.

* **Software** includes:

  * Apps, utilities, operating systems, **BIOS**, firmware, compilers, interpreters, and user-written programs.
  * Even includes **malware** and **antivirus** software.

---

## 📏 2.2 Units of Measurement

* **Power**: watts (W), milliwatts (mW), microwatts (μW), nanowatts (nW)
* **Frequency**: how fast something occurs → measured in **Hz** (cycles per second). Most computers run in MHz/GHz.
* **Clock Cycle**: Regular pulses that dictate when events happen.
* **Data Capacity**: Usually in binary units—e.g., **1 KB = 1024 bytes**.
* **Data Rate**: e.g., 100 million bytes/sec ≈ 95.3 binary MB/sec

### Binary vs Decimal Units

* Binary:

  * 1 KB = 2¹⁰ = **1024 bytes**
  * 1 MB = 1024 KB
  * 1 GB = 1024 MB
* Decimal:

  * 1 kB = 10³ = 1000 bytes (used more in networks and drives)
* Binary terms are still **dominant in hardware contexts**.

---

## 🧠 2.3 Conceptual Computer System

### von Neumann Model:

* **Core idea**: CPU, Memory, I/O Devices, all linked via a **System Bus**
* **System Bus**: carries **data**, **addresses**, and **control signals**
* **Cache**: Very fast, small memory to boost performance

### von Neumann Bottleneck:

* Only one component can use the bus at a time.
* **Limits simultaneous operations**, slows performance.

### Solution: **Harvard Architecture**

* Uses **separate buses** for instructions and data → increases speed.

---

## 💾 2.4 Software Viewpoint

* **Software = instructions** to perform actions on data
* **Early software**: punch cards (like on Jacquard looms)
* **Types of software**:

  * **Compiled** (e.g., C, C++) → converted to machine code by a compiler
  * **Interpreted** (e.g., Python) → executed line-by-line
  * **Assembly language**: human-readable machine code (low-level)

---

## ⚙️ 2.5 Electronics and Logic

* **Transistors** = binary switches
* Logic Gates:

  * **NOT (Inverter)**: flips 1 to 0 and vice versa
  * **AND**: 1 only when both inputs are 1
  * **OR**: 1 when any input is 1
  * **XOR**: 1 when inputs differ
* **Combinational circuits**: made from gates to do math/logical work
* **Clock signal**: syncs activity in digital circuits (tick-tock behavior)
* **Flip-flop (latch)**: stores 1 bit → combine 8 = 1 byte (register)

---

## ⚖️ 2.5.1 Speed vs Complexity

* More logic gates = more **power use** and **heat**, potentially slower.
* **Clock speed** depends on how fast circuits respond.
* **Parallelism** can improve speed without adding delay.

### Real-World Applications:

* **RISC** (Reduced Instruction Set): faster due to simplicity
* **CISC** (Complex Instruction Set): more capable but slower
* **Multicore CPUs**: run tasks in parallel for speed boosts

---

## 🧠 2.6 Summary

* We explored the **basics** of hardware, software, system architecture, digital logic, and speed vs complexity.
* Sets the foundation for deeper study in later chapters.

---

## 🧾 2.7 Key Terms Introduced

* CPU, Cache, Clock, Register, Transistors, Logic Gate
* Software/Hardware, Compiler, Interpreter, BIOS, Firmware
* System Bus, Memory, IO Device, Combinational Circuit