# üß† **Pipelining in CPU Architecture**

## üîç What Is Pipelining?

Pipelining is a technique used in computer architecture to **increase instruction throughput**‚Äîi.e., the number of instructions completed per unit of time. It breaks the instruction execution cycle into separate stages so that **multiple instructions can be in different stages of execution simultaneously**.

### üèÅ Analogy

Think of an assembly line in a factory: while one instruction is being decoded, another can be fetched, and yet another can be executed.

---

## üßÆ Why Use Pipelining?

* **Goal**: Achieve a CPI (Cycles Per Instruction) close to **1**
* **Without pipelining**: Each instruction is executed one at a time from start to finish
* **With pipelining**: Multiple instructions are processed at the same time in different stages

For example, a basic 5-stage pipeline might include:

| Stage | Name               | Description                        |
| ----- | ------------------ | ---------------------------------- |
| IF    | Instruction Fetch  | Get instruction from memory        |
| ID    | Instruction Decode | Decode and read registers          |
| EX    | Execute            | Perform operation (e.g., ALU)      |
| MEM   | Memory Access      | Read/write data memory             |
| WB    | Write Back         | Write result back to register file |

---

## ‚ö†Ô∏è Pipelining Hazards (Problems)

Pipelining isn‚Äôt perfect‚Äîit can run into issues called **hazards** that reduce its effectiveness.

### 1. **Structural Hazards**

* Occur when **hardware resources** are shared across stages and not available when needed
* E.g., Memory being accessed by both the IF and MEM stages at the same time

**Solution**:

* Duplicate hardware (e.g., separate instruction and data memory or caches)
* Carefully schedule instruction flow

---

### 2. **Data Hazards**

* Happen when an instruction depends on the **result of a previous instruction** that hasn‚Äôt completed yet

#### Example:

```asm
ADD R1, R2, R3   ; R1 = R2 + R3
SUB R4, R1, R5   ; R4 = R1 - R5 (needs result from above)
```

* `SUB` depends on the result of `ADD`, but `ADD` hasn't finished yet

#### Solutions:

* **Stalling** (inserting *bubbles* or *NOPs* into the pipeline to wait)
* **Forwarding (bypassing)**: Sends result from one stage directly to a later stage that needs it, without writing to the register file first
* **Reordering**: Move independent instructions in between dependent ones (done by compiler or CPU)

---

### 3. **Control Hazards (Branch Hazards)**

* Occur when the **next instruction depends on the result of a branch**
* CPU doesn‚Äôt know where to go next until the branch decision is made

#### Solutions:

* **Branch prediction**: Guess the branch direction and proceed speculatively
* **Branch delay slots**: Insert useful instructions after the branch to avoid wasting cycles
* **Flushing**: If prediction was wrong, discard incorrect instructions (costs performance)

---

## üß† Optimising Pipeline Efficiency

* **Deeper pipelines** (more stages) allow higher clock rates but may increase penalty on hazards
* **Superscalar execution**: Multiple instructions start in parallel pipelines
* **Out-of-order execution**: Executes instructions as soon as operands are ready, not strictly in program order
* **Register renaming**: Avoids false data dependencies by giving registers temporary aliases

---

## ‚è±Ô∏è Performance

* Ideal CPI = 1
* Real-world CPI depends on how well hazards are managed
* **Pipeline speedup ‚âà number of stages**, assuming no stalls

---

## üß∞ Key Terms

| Term                  | Definition                                                     |
| --------------------- | -------------------------------------------------------------- |
| **Pipeline**          | Division of instruction execution into multiple stages         |
| **Stall (Bubble)**    | Intentional delay inserted to handle hazards                   |
| **Forwarding**        | Bypassing registers to resolve data dependencies quickly       |
| **Hazard**            | Any situation that causes a pipeline delay                     |
| **Branch Prediction** | Guessing outcome of conditional branch to avoid control hazard |
