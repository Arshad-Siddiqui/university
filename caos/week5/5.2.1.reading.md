# üìù Notes on Memory Management

## 11.1 Memory Management

* Memory is a **critical resource** managed by the operating system (OS).
* Limitation: physical memory is finite; applications can demand more memory than is physically available.
* Example: an image editor may start small but then open a huge file requiring much more memory.
* **Na√Øve solution**: error message (‚Äúout of memory‚Äù).
* **Better solution**: Virtual memory (discussed later).

---

## 11.2 Memory Allocation

How programs get memory:

* **Static allocation** ‚Äì fixed block of memory given when the program starts.
* **Dynamic allocation** ‚Äì program requests memory during execution (via `malloc`, `calloc`, `free` in C).
* **Stack memory** ‚Äì default allocation for local variables during execution, managed automatically.

### Memory Release

* Must be **freed** when no longer needed, otherwise causes a **memory leak** (memory reserved but no longer used).

### Fragmentation

* Frequent allocation/deallocation scatters memory blocks, slowing access (like file system fragmentation).

### Code Memory

* Not just data ‚Äì program code itself also needs memory.
* **Linking** determines how program code is allocated:

  * **Static linking**: all code/modules combined into one block. Larger footprint, but faster since everything is loaded.
  * **Dynamic linking**: core loaded first, extra modules only when needed (DLLs). Smaller footprint, but can cause delays when loading new features.

---

## 11.2.1 Memory Access Control

* OS ensures processes **can‚Äôt access each other‚Äôs memory** ‚Üí **Memory protection**.
* Prevents rogue apps from corrupting others or stealing data.
* Shared memory is possible but must be **controlled**.

---

## 11.3 Virtual Memory

* Logical (virtual) address space larger than physical memory.
* Most of it is stored on **secondary storage** (HDD/SSD).
* OS swaps pieces of virtual memory into physical memory as needed.

### Key Concepts

* **Paging**: divide memory into fixed-size pages (1‚Äì8 KB typical).
* **Page table**: maps virtual addresses to physical addresses.
* **Page fault**: when requested data isn‚Äôt in physical memory ‚Üí must fetch from disk.
* **Swap file/disk**: storage used for paging.

### Performance

* Disk access is slow ‚Üí paging introduces **cost penalties**.
* **Thrashing**: when system spends more time paging than doing useful work.
* Mitigations:

  * Add more RAM.
  * Use faster swap disks/SSDs.
  * Pin important pages in memory (never swap them).
  * Distribute workload across multiple systems.

---

## 11.4 Inter-Process Communication (IPC)

Allows processes to exchange data under OS supervision.

* **Pipes**:

  * One-way communication channels (FIFO).
  * Named pipes allow unrelated processes to communicate.
* **Message Queues**:

  * More flexible than pipes.
  * Support point-to-point, fan-in, fan-out, and collective communication.
  * Each message has a header + data.
* **Shared Memory**:

  * Very fast communication (direct memory access).
  * Requires **synchronisation** (mutex, semaphores) to avoid race conditions.

---

## 11.5 Privileges and Restrictions

* OS defines **privilege levels** to enforce security.

### Kernel Mode

* Full access to memory and CPU instructions.
* Reserved for OS tasks.

### User Mode

* Restricted memory and CPU access.
* User programs must request privileged operations via **system calls**.

### Why Privileges?

* Prevents rogue apps from crashing system or stealing/corrupting data.
* Protects memory areas and ensures stability.

---

## Terminology

* **Virtual Memory**: illusion of larger memory using disk + RAM.
* **Page Fault**: when data isn‚Äôt in physical memory, must fetch from disk.
* **Memory Leak**: memory allocated but never freed.
* **Paging Supervisor**: OS component managing paging.
* **Swap Disk/File**: storage for virtual memory.
* **IPC**: mechanisms for process communication (pipes, queues, shared memory).
* **Mutex/Semaphore**: tools for synchronisation in shared memory.
* **Kernel Mode/User Mode**: privilege levels for tasks.

---

# ‚ùì Questions of the Day

### 1. How does virtual memory influence OS design and performance?

* **Influence**: lets OS run more tasks than physical RAM would allow.
* **Trade-offs**: improves usability and flexibility, but paging and thrashing can hurt performance.

### 2. How do IPC mechanisms support coordination? Why strict access control?

* **Pipes, queues, shared memory** allow processes to exchange data efficiently.
* Strict OS enforcement prevents corruption, data theft, and race conditions, ensuring reliability and security.