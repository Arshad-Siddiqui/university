# Exceptional Control Flow (ECF)

* **Control flow**: Normal program execution moves instruction by instruction.
* **Abrupt changes** (jumps, calls, returns) → necessary for program logic.
* But systems must also handle **external events**: timers, I/O completions, process terminations, etc.
* These events trigger **Exceptional Control Flow (ECF)** → abrupt transfers of control outside normal sequential flow.

### Why ECF matters

* Foundation for **I/O, processes, and virtual memory** in OS.
* Mechanism for **application ↔ kernel interaction** (system calls).
* Key to **concurrency**: interrupts, signals, overlapping threads.
* Links **low-level hardware events** with **high-level program behavior**.
* Explains both **hardware-level exceptions** and **software exceptions** (e.g., `try/catch` in Java, `setjmp/longjmp` in C).

---

# 8.1 Exceptions

* **Definition**: An abrupt change in control flow caused by a change in the processor’s state, detected by hardware, handled by software (OS).
* Triggered by **events**, either synchronous (from current instruction) or asynchronous (external device).

### How Exceptions Work

1. Event occurs (e.g., divide by zero, timer, I/O complete).
2. Processor consults **exception table** (jump table mapping event → handler).
3. Jumps to **exception handler** in kernel mode.
4. Handler decides: resume program (re-execute or continue), or abort program.

---

## Four Classes of Exceptions

1. **Interrupts**

   * **Cause**: External I/O devices (e.g., keyboard, disk, NIC).
   * **Async** (not tied to current instruction).
   * Always return to **next instruction**.
   * Used for device notifications.

2. **Traps (System Calls)**

   * **Cause**: Intentional program instruction (e.g., `syscall`).
   * **Sync**.
   * Always return to **next instruction**.
   * Main mechanism for **programs to request OS services** (file I/O, process creation, etc.).

3. **Faults**

   * **Cause**: Potentially recoverable error (e.g., **page fault**).
   * **Sync**.
   * Handler may **fix** and **re-execute current instruction**; otherwise, abort.
   * Example: loading a missing memory page from disk.

4. **Aborts**

   * **Cause**: Fatal, unrecoverable hardware error (e.g., parity/machine check).
   * **Sync**.
   * Never return—program is terminated.

---

### Exceptions in Linux (x86-64 examples)

* **Faults**: Divide error (0), General Protection Fault (13), Page fault (14).
* **Abort**: Machine check (18).
* **OS-defined**: 32–255 reserved for interrupts & traps.
* **System calls**: Linux provides hundreds (e.g., `read`, `write`, `fork`, `execve`).

  * Invoked via `syscall` instruction.
  * Arguments passed via registers (`rax`, `rdi`, `rsi`, etc.).
  * Runs in **kernel mode**.

---

# System Calls: Controlled Entry to Kernel

* **System calls** = traps that transfer control from user space → kernel space.
* Provide **safe, controlled interface**:

  * File operations (`read`, `write`, `open`, `close`).
  * Process management (`fork`, `execve`, `wait`).
  * Memory management (`mmap`, `brk`).
* Wrapper functions (in C libraries) hide syscall details from programmers.
* Critical: ensures user programs can’t directly execute privileged instructions.

---

# Key Distinctions

* **Hardware-generated exceptions**:

  * Triggered by events at the processor level (e.g., page faults, I/O interrupts).
  * Essential for OS-level resource management and protection.
  * Handled in **kernel mode**, tightly coupled with CPU state.

* **Software exceptions (high-level languages)**:

  * Programmer-defined error handling (`try/catch`, `throw`).
  * Application-level only, no privileged instructions.
  * Often implemented using lower-level ECF (`setjmp/longjmp`).

---

# Q\&A

### How do system calls enable programs to safely and effectively communicate with the OS kernel?

* System calls are **intentional traps** that move execution into **kernel mode** in a controlled way.
* They ensure **safety** by preventing user code from directly executing privileged instructions.
* They provide **effectiveness** by exposing standard APIs (e.g., file I/O, process control) without revealing hardware complexity.
* Without syscalls, user programs would risk destabilizing or compromising the OS.

### In what ways do hardware-generated exceptions like interrupts differ from software exceptions in high-level programming languages, and why is this distinction important?

* **Hardware exceptions** are triggered by **real events** (device signals, memory faults) and are essential for managing hardware, concurrency, and system stability.
* **Software exceptions** are triggered by **program logic** errors and help maintain application robustness.
* The distinction is important because:

  * Hardware exceptions require **kernel-level intervention** to protect the system.
  * Software exceptions are **contained within the program** and don’t endanger other processes.
* Recognizing this difference helps programmers design robust systems and distinguish between system-level errors and application-level errors.

---

# Summary

An operating system (OS) acts as the middle layer between hardware and software, allowing users to interact with the computer while efficiently managing resources. Unlike bare-metal systems, where applications run directly on hardware, the OS provides abstraction layers like the BIOS and especially the kernel, which coordinates key tasks such as process scheduling, memory handling, and device control.

Programs communicate with the OS through system calls, which offer a safe way to request services or access hardware without direct control. To handle unexpected or special events, the OS uses Exceptional Control Flow (ECF), which includes mechanisms like interrupts, traps, faults, and aborts. These ensure that hardware signals or errors are properly managed at the system level.

Finally, it’s important to distinguish between OS-level exceptions (which handle hardware and system events) and language-level exceptions (such as try/catch in programming). Linux provides clear examples of how the system manages these exceptions to maintain stability and control.