# Concurrency in Modern Operating Systems: Key Issues

## Thread Safety

* **Definition**: A function is *thread-safe* if it consistently produces correct results when executed by multiple threads concurrently.
* **Thread-unsafe function classes**:

  1. **Unprotected shared variables**

     * Example: Incrementing a global counter without locks.
     * Fix: Use synchronization primitives (mutexes, semaphores).
  2. **Functions that maintain state across invocations**

     * Example: `rand()` uses static/global state. Multiple threads calling it break assumptions.
     * Fix: Rewrite to eliminate static data, pass state as an argument.
  3. **Functions returning pointers to static variables**

     * Example: `ctime()` or `gethostbyname()`. Results for one thread can be overwritten by another.
     * Fix: *Lock-and-copy* (protect call with a mutex and copy result into thread-local storage).
  4. **Functions that call thread-unsafe functions**

     * Whether they’re thread-safe depends on the called function and protections applied.

---

## Reentrancy

* **Definition**: A reentrant function is a special case of thread-safe functions.

  * It **does not reference shared state** (global/static variables).
  * Instead, it uses **only local variables or caller-passed data**.
* **Explicitly reentrant**: All arguments passed by value, no globals/statics.
* **Implicitly reentrant**: Uses pointers, but correctness depends on caller passing non-shared memory.
* **Why it matters**:

  * Reentrant functions avoid synchronization overhead → more efficient.
  * Converting class 2 (stateful) thread-unsafe functions requires rewriting them as reentrant.
  * Example: `rand_r()` is a reentrant version of `rand()`.

---

## Using Library Functions in Threaded Programs

* Most Linux and C standard library functions are thread-safe.
* **Exceptions**: Some functions are **thread-unsafe**:

  * `rand` → use `rand_r`
  * `strtok` → use `strtok_r`
  * `ctime`, `asctime`, `localtime` → use `_r` variants (e.g., `ctime_r`)
  * `gethostbyname`, `gethostbyaddr`, `inet_ntoa` → use reentrant alternatives.
* **Problem with lock-and-copy**:

  * Slows performance due to synchronization.
  * Requires deep copying for complex return structures.
  * Doesn’t fix stateful functions like `rand`.

**Takeaway**: Always prefer reentrant (`*_r`) versions of unsafe library functions in multithreaded code.

---

# Key Differences

### Thread Safety vs. Reentrancy

* **Thread-safe**: Ensures correctness with concurrent calls, often using synchronization (may incur overhead).
* **Reentrant**: Subset of thread-safe; relies only on local or caller-provided data → avoids overhead and is inherently safe.

### OS-Level Exceptions vs. Language Exceptions (context tie-in)

* OS-level (interrupts, traps, faults) handle hardware/software events at system level.
* Language exceptions (`try/catch`) handle program logic errors.
* Important distinction: OS exceptions affect system state, language exceptions affect application logic.

---

# Answers to Guiding Questions

**How do thread safety and reentrancy differ, and why is it important to understand both when designing multithreaded applications?**

* Thread safety ensures correctness across threads, often through locking. Reentrancy ensures correctness without shared state, making functions inherently thread-safe and more efficient. Developers must understand both because using only synchronization may degrade performance, while reentrancy often requires deeper code redesign.

**What risks might arise from using standard library functions in a multithreaded program, and how can you mitigate these risks?**

* Risks: Data corruption, race conditions, incorrect outputs when functions rely on shared static state.
* Mitigation: Use reentrant (`*_r`) alternatives, lock-and-copy wrappers when unavoidable, or redesign code to avoid unsafe functions.