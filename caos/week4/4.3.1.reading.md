# üñ•Ô∏è Workload Management Notes (Ch.10.1‚Äì10.7)

## 10.1 The Task in Hand

* **Processes**: Independent programs managed by the OS.

  * Each process gets its own private memory ‚Üí prevents data leakage, protects from crashes.
  * OS keeps them in a task list and assigns CPU time.
* **Threads**: Lightweight units inside a process.

  * Share the parent‚Äôs memory space, so they can easily communicate.
  * Useful for concurrency within a single program (e.g., microphone recording thread + disk writing thread + GUI update thread running ‚Äúat once‚Äù).

üí° *Analogy*: Processes = separate houses; Threads = rooms inside a house that share utilities.

---

## 10.2 Process ID & Housekeeping

* Each process has a **PID (process identifier)** = unique number.
* **PCB (Process Control Block)**: Record storing a process‚Äôs state (running, waiting, priority, CPU registers, parent info).
* Scheduler uses PCBs to decide which process runs next.

---

## 10.3 Thread Management Models

1. **User-level threads**:

   * Managed within the process by its own scheduler.
   * Invisible to the OS kernel.
   * Flexible but limited‚Äîif one thread blocks, the OS may block the whole process.
2. **Kernel-level threads**:

   * Created and managed by the OS kernel.
   * Kernel scheduler decides their execution.
   * More overhead but gives the OS visibility and control.

*Modern OS usually prefer kernel-level threading for fairness and consistency.*

---

## 10.4 Task Scheduling

* Early systems: **serial execution** (one job at a time).
* Modern systems: **time-slicing** ‚Üí illusion of parallelism by interleaving small parts of tasks.
* **Scheduler**: The OS component that decides when and how tasks run.
* **Context switch**: Pausing one process and resuming another (saves/restores CPU state).
  ‚ö† Overhead: too much switching wastes CPU time.

---

## 10.5 Scheduling Algorithms

* **Round-robin** (SimpleSched example): Equal time slices to each task in turn.

  * Fair but inefficient: important tasks may wait too long; idle tasks waste CPU time.
* **Task scheduling queues**: Tasks organised into queues (not just lists), allowing more sophisticated policies.

---

## 10.6 Preemptive Scheduling

* **Preemptive**: Tasks are forcibly switched by the OS (e.g., using a timer like the **Repetitive Interrupt Timer, RIT**). Ensures fairness and responsiveness.
* **Non-preemptive**: Tasks voluntarily give up control (risk: selfish or buggy tasks hog CPU).
* **Priority levels**: High-priority tasks can get longer or more frequent slices.
* **Yielding**: Tasks can voluntarily release the CPU early if idle, improving efficiency.

üîë *Determinism*: With fixed slices, system behaviour is predictable. With yielding, performance is less predictable (problematic in real-time systems ‚Üí ‚Äújitter‚Äù).

---

### 10.6.1 Multiple Queues

* Separate queues for **ready tasks** and **I/O-waiting tasks**.
* Prevents wasting time resuming tasks that just yield immediately.
* Improves CPU utilisation.

---

### 10.6.2 Interrupts vs Polling

* **Polling**: Task repeatedly checks a device‚Äôs status. Simple but wasteful (CPU cycles wasted while waiting).
* **Interrupts**: Device signals the CPU when ready (e.g., disk read complete).

  * CPU can run other tasks until interrupted.
  * Enables efficient multitasking and sharing of CPU across users.

---

## 10.7 Achieving Priority

* Prioritisation ensures critical tasks (e.g., video recording, real-time control) run ahead of less urgent ones (e.g., background report).
* Examples:

  * **Linux nice levels**: -20 (highest priority) ‚Üí +19 (lowest).
  * **RTOS (Real-Time OS)**: May use *Earliest Deadline First (EDF)* instead of fixed priority.
* Implementation strategies:

  * Different time-slice lengths.
  * Skipping low-priority tasks in queues.
  * Multiple priority queues.

---

# üåü Answers to Guiding Questions

**Q1: How does preemptive scheduling contribute to system responsiveness, and what challenges arise in fairness?**

* Preemptive scheduling ensures no single task hogs the CPU ‚Üí responsive system (e.g., UI still reacts while a big computation runs).
* Challenge: balancing fairness and efficiency. High-priority tasks may starve low-priority ones. Too-frequent context switching wastes CPU time.

**Q2: How do interrupts and polling differ, and why does it matter for real-time systems?**

* Polling = constant checking ‚Üí wastes cycles, increases jitter.
* Interrupts = event-driven ‚Üí CPU only reacts when needed, reducing waste.
* In real-time systems, interrupts are vital to meet deadlines (e.g., aircraft control). Polling would degrade performance and predictability.