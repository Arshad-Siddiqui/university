Here are some fresh and detailed notes from **From Architectures to Operating Systems, Chapter 13, Sections 13.6–13.9**:

---

# Network Node Identification, Services, and Distributed Systems

## 1. Network Node Identification

* **Why identification matters**: For communication, every device (node) on a network needs a **unique identifier** to avoid confusion.
* **MAC Address** (Media Access Control):

  * Assigned by the hardware manufacturer.
  * Fixed, globally unique (in theory).
  * Six pairs of hexadecimal digits (e.g., `00:1A:2B:3C:4D:5E`).
  * Tied to the network card itself.
* **IP Address** (Internet Protocol):

  * Assigned dynamically (by ISP, router, or DHCP).
  * Identifies a device on the Internet or local network.
  * **IPv4**: 32-bit, \~4.3 billion addresses (already exhausted).
  * **IPv6**: 128-bit, essentially unlimited addresses.
* **DNS (Domain Name System)**: Maps human-readable domain names (e.g., `www.google.com`) to IP addresses.

  * Provides flexibility: IPs can change without disrupting service.

---

## 2. Network Services

* A **network service** is any functionality delivered over a network (e.g., email, web browsing, video streaming).
* Examples:

  * **SSH**: Secure remote login.
  * **FTP**: File transfer.
  * **HTTP**: Web browsing.
  * **SMTP/POP**: Email exchange.
  * **X11**: Remote graphical interfaces.
* Services rely on **protocols** (rules for data exchange) to ensure consistency and reliability.

---

## 3. Sockets Interface

* **Definition**: A programming abstraction that lets applications send and receive data over a network.
* Each socket is defined by:

  * **IP address** (device).
  * **Port number** (specific service/application).
* Example:

  * Server → `144.32.128.230:1228`
  * Client → `144.146.128.200:3007`
* Reserved ports (0–1023): Standard services like HTTP (80), HTTPS (443), FTP (21).
* Higher ports (1024–65535): Dynamically assigned for applications.
* **Analogy**: Like pipes between processes, but across different machines.

---

## 4. Distributed Systems

* **Definition**: A system where functionality is split across multiple computers, working together to achieve a task.
* **Example**:

  * Remote heating system with client app → communicates via SSH → server at home controls the heating.
  * Later redesigned as a web app (client uses just a browser; server provides GUI + logic).
* **Advantages**:

  * Scalability: Add more nodes to handle bigger workloads.
  * Reliability: Failures in one node may not stop the whole system.
  * Efficiency: Tasks can be spread across locations/resources.
* **Drawbacks**:

  * Updating requires coordination between client & server software (unless centralised via web apps).
  * More complex management.

---

## 5. Web-Based Client-Server Systems

* Instead of bespoke client software, systems can run entirely through **web browsers**.
* **Process**:

  * User sends a request (HTTP).
  * Server interprets and responds with a webpage.
  * Server-side software handles all the logic (maintenance becomes easier).
* **Benefits**:

  * No need for special client software.
  * Easy updates (server-side only).
  * Compatible across devices.
* **Modern web apps** often use JavaScript for interactivity, and CGI/PERL or similar on the server side for logic.

---

# Key Questions Answered

### Q1: How does understanding network node identification and the sockets interface help design or troubleshoot communication?

* Node identification ensures devices are uniquely recognised on a network. Knowing whether an issue lies with the MAC (hardware), IP (assignment/routing), or DNS (name resolution) helps isolate problems.
* The sockets interface gives a consistent programming model: developers can design reliable client-server communication, and troubleshoot issues by checking ports, protocols, and address bindings.

### Q2: How do distributed systems and the client-server model influence reliability and scalability?

* **Reliability**: By spreading workloads across multiple nodes, failures in one component don’t bring down the entire service. For example, a web server cluster can handle traffic even if one server goes offline.
* **Scalability**: Services can grow with demand by adding more servers or clients. Cloud platforms exploit this by virtualising and distributing workloads.
* **Client-server model** simplifies design: clients request services, servers respond. This keeps clients lightweight while servers handle the heavy lifting.

---

✅ That’s a thorough, fresh-eyes-friendly set of notes with the **important terms defined, explained, and contextualised**.