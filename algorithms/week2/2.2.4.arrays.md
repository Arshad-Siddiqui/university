# ✅ Week 2: **Arrays and Efficient Searching**

---

## 🔢 Bits and Bytes

### ➤ **Bits**

* The smallest unit of data in computing: a binary value (0 or 1).

### ➤ **Bytes**

* 1 byte = **8 bits**
* Every byte in memory has a **unique address**.
* Programming languages use **variables (identifiers)** to reference memory addresses indirectly.
  Example:

  ```py
  x = 12  # 'x' refers to a memory location storing value 12
  ```

---

## 📦 Arrays: Managing Sequences in Memory

* Arrays store **related values in contiguous memory**, i.e., back-to-back with no gaps.
* Each element in an array must occupy the **same number of bytes**, allowing consistent indexing.
* This layout allows **constant-time (O(1)) access**:

  > Memory address of element = `base_address + (index × cell_size)`

### ➤ Python-specific Note

* Python strings are sequences of Unicode characters.
* Each character may take **2 bytes or more**, depending on encoding (`utf-16`, `utf-32`, etc.).

---

## 🧱 Cells and Indexing

* Each element is stored in a **cell**.
* Arrays are **zero-indexed**: the first element is at index `0`.

Example:

```py
arr = ['a', 'b', 'c']
arr[0]  # 'a'
```

---

## 🚫 Limitations of Static Arrays

* **Fixed size** at creation to reserve contiguous memory.
* Cannot grow or shrink dynamically.
* Tuples and strings in Python are **immutable**, reinforcing this restriction.

---

## 🔄 Dynamic Arrays (e.g., Python Lists)

* Built on static arrays **with extra capacity** pre-allocated.
* When full:

  * A **larger array** is allocated.
  * All elements are **copied over**.
  * Old memory is **released** (garbage collected).

> This copying makes dynamic arrays **less memory efficient** but more flexible.

---

## ✅ Static vs Dynamic Arrays: Trade-offs

| Feature      | Static Arrays           | Dynamic Arrays (Lists)      |
| ------------ | ----------------------- | --------------------------- |
| Size         | Fixed                   | Flexible                    |
| Speed        | Faster access/update    | Slight overhead on resizing |
| Memory usage | Efficient               | May reserve extra memory    |
| Mutability   | Immutable (e.g., tuple) | Mutable (e.g., list)        |

---

## 🔍 Optimising Search: Sorted vs Unsorted Arrays

### ➤ Linear (Sequential) Search

* Works on any array.
* Check every element until target is found or list ends.
* **Time complexity**: O(n)

### ➤ Binary Search (on Sorted Arrays)

* Divides search range in half with each step.
* Requires elements to be **sorted** beforehand.
* **Time complexity**: O(log n)

#### Binary Search Logic:

1. Start with `low = 0`, `high = len(arr) - 1`
2. Calculate `mid = (low + high) // 2`
3. If `arr[mid] == target`: found!
4. If `arr[mid] < target`: search right half
5. If `arr[mid] > target`: search left half
6. Repeat until `low > high`

---

## 🧠 Why Contiguous Memory Matters

* Enables **efficient index-based access**:

  ```plaintext
  Address of element = start_address + (index × size_per_cell)
  ```

* If elements were scattered in memory, we’d need to store **explicit pointers**, losing the speed advantage.

---

## 📌 When to Use Static vs Dynamic Arrays

| Scenario                                | Choice                       |
| --------------------------------------- | ---------------------------- |
| Fixed-size data known at compile time   | Static array (less overhead) |
| Data size unknown or changes frequently | Dynamic array (flexible)     |

---

## 🧪 Modelling Problem (Lottery Optimisation)

[Lottery Activity →](https://onlinestudy.york.ac.uk/courses/1637/pages/2-dot-2-7-activity-modelling-a-lottery-ticket-optimisation-problem?module_item_id=128890)

* **Problem setup**:

  * Choose 6 numbers from 15.
  * 4 numbers are winning numbers.
  * You win if 3 or more selected numbers are winning ones.
  * Objective: **minimize number of tickets** to **guarantee** a win.

### 🔁 Brute-force Strategy

* Generate all possible 6-number combinations.
* Check each combination until you find one that contains 3+ winning numbers.
* Computationally expensive: **combinatorial explosion** as number range increases.

### 🔧 Improvements

* Avoid duplicate combinations.
* Optimise generation by skipping repeated elements.
* Explore **combinatorics** and **set coverage** principles for efficiency.

---

## ✅ Summary

* **Arrays** are efficient for fixed-size, uniform data.
* **Dynamic arrays** (like Python lists) are more flexible but costlier in performance.
* **Contiguous memory** allows fast indexing.
* Use **binary search** where possible to drastically reduce search times.
* Choose data structures based on **problem constraints and performance needs**.