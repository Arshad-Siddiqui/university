# 📚 4.5 Linked Lists

Linked lists are flexible data structures that **do not store elements contiguously**. Instead, they consist of nodes that contain data and references (pointers) to other nodes. They're ideal for situations where the size of the data structure changes frequently.

---

## 📌 Why Use Linked Lists?

* **Dynamic memory allocation** – adjust size as needed
* **Efficient insertions and deletions** – especially at the head or tail
* **No need for contiguous memory** – unlike arrays

---

## 🔧 Structure

A **node** in a linked list contains:

1. A data element
2. A reference (pointer) to the next node

![Linked list diagram](image-7.png)

The final node points to `null` (or `None` in Python), indicating the end of the list.

---

## 🛠 Linked List Operations

| Operation | Description                                      |
| --------- | ------------------------------------------------ |
| Insertion | Add elements anywhere without shifting           |
| Deletion  | Remove elements by updating pointers             |
| Traversal | Move from node to node manually                  |
| Overall   | Flexible but typically less efficient for access |

---

## 🔁 Types of Linked Lists

### Singly Linked List

* Each node has one pointer (to the next node)
* Easy to move forward
* Difficult to traverse backwards

![Singly linked list](image-9.png)

---

### Doubly Linked List

* Nodes point **both forward and backward**
* Easier to navigate in either direction
* Uses more memory and is more complex

![Doubly linked list](image-10.png)

---

### Circularly Linked List

* Tail node points back to the head
* Can be singly or doubly linked
* Useful when there's no defined "start" or "end" (e.g., round-robin schedulers)

![Circularly linked list](image-11.png)

---

## ✅ Advantages

* Dynamically resizable
* Efficient insertion and deletion at head or tail
* No need for contiguous memory

## ❌ Disadvantages

* No constant-time indexing (must traverse)
* Higher memory overhead (due to pointers)
* More complex to implement, especially doubly and circularly

---

## 🧠 Integration with Lists

There are two main ways to implement lists:

1. **Dynamic arrays**
2. **Linked lists**

### Regular Arrays

* Fixed size and contiguous
* Fast element access via index math
* Insertion/removal is inefficient due to shifting

### Dynamic Arrays

* Expand as needed (typically doubling size)
* Better memory usage than huge pre-allocated arrays
* Insertions at the end are efficient, but insertions/removals at the start are expensive

### Linked Lists as Solution

* No need for shifting
* Efficient insertion/removal at head or tail
* Slower traversal and access due to pointer hopping

---

## ⚙ Linked List Operations (Summary)

| Operation               | Dynamic Array | Linked List                |
| ----------------------- | ------------- | -------------------------- |
| Access by Index         | ✅ O(1)        | ❌ O(n)                     |
| Insert/Delete at Head   | ❌ O(n)        | ✅ O(1)                     |
| Insert/Delete at Tail   | ✅ O(1)\*      | ✅ O(1) (with tail pointer) |
| Insert/Delete in Middle | ❌ O(n)        | ❌ O(n)                     |
| Memory Usage            | Compact       | Higher (due to pointers)   |

---

## 🔂 List Implementation in Python

**Examples:**

* [Linked list implementation](/algorithms/week4/python_/linkedadt.py)
* [Linked stack](/algorithms/week4/python_/linked_stack.py)
* [Linked queue](/algorithms/week4/python_/linked_queue.py)

---

## 🔁 Circularly Linked Lists

Used in systems like **Round Robin Schedulers**, where each process gets a turn in sequence.

**Steps:**

1. Service front of queue
2. Rotate

Avoid reallocating memory by rotating a pointer instead of removing and re-adding items.

[Python example](/algorithms/week4/python_/circular_queue.py)

---

## 🧱 Doubly Linked Lists

Doubly linked lists add a `prev` reference in addition to `next`.

Use **sentinel (dummy) nodes** at the start (header) and end (trailer) to simplify edge cases.

### Benefits of Sentinels:

* Eliminate need for special cases on insert/delete
* Ensure that all "real" nodes are always between the header and trailer

**Initial Setup:**

* `header.next → trailer`
* `trailer.prev → header`
* Other attributes set to `None`

📖 [Doubly Linked List Reference – Page 275](https://ebookcentral.proquest.com/lib/york-ebooks/reader.action?c=UERG&docID=4946360&ppg=297)

Can be used to implement **Deques**

---

## 🧑‍💻 Singly Linked List Pseudocode

### Insert at Head

```python
def add_node_to_head(value):
    new_node = Node(value)
    new_node.next = self.head
    self.head = new_node
    self.size += 1
```

### Insert at Tail (with tail pointer)

```python
def insert_element_at_tail(value):
    new_node = Node(value)
    new_node.next = None
    self.tail.next = new_node
    self.tail = new_node
    self.size += 1
```

### Remove Head

```python
def remove_head_node():
    if self.head is None:
        raise ValueError("List is empty")
    self.head = self.head.next
    self.size -= 1
```

### Remove Tail (inefficient in singly)

* Requires traversal to penultimate node
* Not recommended in singly linked lists

---

## 🔁 Use Cases

### Stacks with Singly Linked Lists

* Insert/delete at head
* Simple, efficient (O(1))

### Queues with Singly Linked Lists

* Insert at tail, remove at head
* Maintain both `head` and `tail` pointers

🔧 Edge Case:
When dequeuing the last element, set both `head` and `tail` to `None` to avoid bugs.

---

## 🧠 Notes on Amortized Time

> Amortized cost: Average time per operation over a sequence.
> Even though copying a full array (O(n)) is expensive, it happens infrequently enough that the *average cost* per operation remains O(1).

---

## 📌 Summary

| Data Structure       | Access | Insert/Delete (Head) | Insert/Delete (Tail) | Memory    |
| -------------------- | ------ | -------------------- | -------------------- | --------- |
| Dynamic Array        | ✅ O(1) | ❌ O(n)               | ✅ O(1)\*             | Efficient |
| Singly Linked List   | ❌ O(n) | ✅ O(1)               | ✅ O(1)\*             | Higher    |
| Doubly Linked List   | ❌ O(n) | ✅ O(1)               | ✅ O(1)               | Highest   |
| Circular Linked List | ❌ O(n) | ✅ O(1)               | ✅ O(1)               | Moderate  |

> \*Requires maintaining `tail` pointer