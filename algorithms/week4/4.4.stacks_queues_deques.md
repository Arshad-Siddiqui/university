# 4.4 Lesson 2: Stacks, Queues, and Deques

In this lesson, we explore **Abstract Data Types (ADTs)**‚Äîmodels that define data behavior, independent of implementation. ADTs make algorithm design more efficient and intuitive by focusing on what operations are **available**, **not** how they‚Äôre **implemented**.

---

## üß± Stacks

**LIFO (Last In, First Out)**

The most recently added item is the first one to be removed.

### Common Use Cases:

* Undo functionality (e.g., in text editors)
* Function call management (call stack)
* Matching delimiters like `()`, `{}`, `[]`

### Stack Operations:

| Operation           | Description                                     |
| ------------------- | ----------------------------------------------- |
| `push(item)`        | Adds an item to the top of the stack            |
| `pop()`             | Removes and returns the item at the top         |
| `top()` or `peek()` | Returns the item at the top without removing it |
| `is_empty()`        | Checks whether the stack is empty               |
| `len()` or `size()` | Returns the number of elements in the stack     |

> All stack operations typically run in **O(1)** time.

üìπ [Video Example](https://onlinestudy.york.ac.uk/courses/1637/pages/4-dot-4-1-video-lecture-abstract-data-structures-adt?module_item_id=128943)

---

## üîÅ Queues

**FIFO (First In, First Out)**

The earliest added item is the first to be removed.

### Common Use Cases:

* Task scheduling in operating systems
* Managing customer service requests
* Print queue management

### Queue Operations:

| Operation             | Description                                 |
| --------------------- | ------------------------------------------- |
| `enqueue(item)`       | Adds an item to the rear of the queue       |
| `dequeue()`           | Removes and returns the item at the front   |
| `first()` or `peek()` | Returns the front item without removing it  |
| `is_empty()`          | Checks if the queue is empty                |
| `len()` or `size()`   | Returns the number of elements in the queue |

### Queue Example:

```python
original_queue = [20, 10, 50]
enqueue(40)        # [20, 10, 50, 40]
dequeue()          # [10, 50, 40] -> returns 20
first()            # returns 10
is_empty()         # returns False
len(queue)         # returns 3
```

---

### ‚úÖ Queue Advantages Over Stacks

* Maintains element **order**
* Ideal for **real-time processing** and **task scheduling**

### ‚ùå Disadvantages

* Cannot directly access middle elements
* No easy backtracking (unlike stacks)

---

## üîÑ Deques (Double-Ended Queues)

**Flexible** data structure that allows additions and removals from **both ends**.

### Common Use Cases:

* **Sliding window algorithms** (e.g., in signal processing)
* **Palindrome checking**
* **Undo/redo systems** (stores recent actions at both ends)

### Deque Operations:

| Operation           | Description                                 |
| ------------------- | ------------------------------------------- |
| `add_first(item)`   | Inserts item at the front                   |
| `add_last(item)`    | Inserts item at the rear                    |
| `delete_first()`    | Removes and returns the item from the front |
| `delete_last()`     | Removes and returns the item from the rear  |
| `first()`           | Returns the front item without removing it  |
| `last()`            | Returns the rear item without removing it   |
| `is_empty()`        | Checks if the deque is empty                |
| `len()` or `size()` | Returns the number of elements              |

---

### ‚úÖ Advantages

* **Flexibility**: Add/remove items from both ends
* **Efficient**: Constant-time operations on front and rear

### ‚ùå Disadvantages

* **No direct access** to middle elements
* **Higher memory overhead**: Must account for dynamic expansion at both ends
