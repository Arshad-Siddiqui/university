# ğŸ“Œ Trees vs. Linear Structures

* Linear structures: one-dimensional (lists, arrays).
* Trees: **hierarchical**, support **branching**, and model natural structures like file systems and inheritance.

---

### ğŸŒ³ **Terminology Recap**

| Term                     | Meaning                                       |
| ------------------------ | --------------------------------------------- |
| **Root**                 | Topmost node, no parent.                      |
| **Parent/Child**         | Direct relationship; child has only 1 parent. |
| **Siblings**             | Nodes with same parent.                       |
| **Leaf (External Node)** | No children.                                  |
| **Internal Node**        | Has children.                                 |
| **Subtree**              | Any node and all its descendants.             |
| **Edge**                 | Link between parent and child.                |
| **Path**                 | Sequence of edges.                            |
| **Depth(p)**             | Edges from root to `p`.                       |
| **Height(p)**            | Longest path from `p` to a leaf.              |

> ğŸ” *Depth is how far a node is from the root. Height is how far a node is from the leaves.*

---

### ğŸ§± **Tree ADT & Python Implementation**

Using **Position** objects to abstract nodes is key.

* Example accessor:

  ```py
  T.parent(p)  # returns the parent of p
  T.children(p)  # iterable of pâ€™s children
  T.is_leaf(p)  # True if p has no children
  ```

* Example concrete helper:

  ```py
  def is_root(self, p):
      return self.root() == p
  ```

> These make traversal & manipulation more intuitive and maintain abstraction.

---

### â« **Depth & Height**

* **Depth(p)**: recursive, `O(d_p)`

  ```py
  def depth(self, p):
      if self.is_root(p):
          return 0
      else:
          return 1 + self.depth(self.parent(p))
  ```

* **Height(p)**: recursive, max over all child heights

  ```py
  def height(self, p):
      if self.is_leaf(p):
          return 0
      else:
          return 1 + max(self.height(c) for c in self.children(p))
  ```

---

### ğŸŒ² **Binary Trees**

* **Binary Tree**: max 2 children (left/right).
* **Proper (Full)**: 0 or 2 children.
* **Complete**: balanced and filled left to right.

Python ADT:

```py
t.left(p)
t.right(p)
t.sibling(p)
```

> `children(p)` in BinaryTree returns left and right (if they exist), in order.

---

### ğŸ§¬ **LinkedBinaryTree (Concrete Implementation)**

Private `_Node` class + public `Position` abstraction.

Setter methods include:

```py
T.add_root(e)
T.add_left(p, e)
T.add_right(p, e)
T.replace(p, e)
T.delete(p)
T.attach(p, T1, T2)
```

> Efficient (`O(1)`) and modifies structure safely.

---

### ğŸ“š **Tree Traversal Algorithms**

All `O(n)` because every node must be visited.

#### ğŸ” Preorder

* Visit node, then children recursively (root first).

#### ğŸ” Postorder

* Visit children first, then the node (root last).

#### ğŸ” Breadth-First (Level-order)

* Use a queue. Traverse all nodes at each depth before going deeper.

#### ğŸ” Inorder (Binary Trees only)

* Left, Node, Right.
* Used in **Binary Search Trees** to get sorted order.

---

### ğŸ§  **Binary Search Tree (BST)**

* BST invariant: `left < node < right`
* Traversal used for search decisions: go left or right.
* Performance: O(height) â€” which could be bad if unbalanced (like a linked list).

---

### ğŸ§µ **Implementing Traversals in Python**

Use generator methods:

```py
def preorder(self):
    yield from self._preorder_subtree(self.root())

def _preorder_subtree(self, p):
    yield p
    for c in self.children(p):
        yield from self._preorder_subtree(c)
```

# Traversal explanations

## ğŸŒ± 1. **Inorder Traversal** (`Left â†’ Root â†’ Right`)

### ğŸ”§ How it works:

* Goes as far left as possible.
* Then visits the node.
* Then explores the right subtree.

### ğŸ§  Use cases:

* **Sorted output of a Binary Search Tree (BST)**
  ğŸ‘‰ This is the *most common use case*. Inorder traversal of a BST gives nodes **in ascending order**.
* **Check if a tree is a BST**
  ğŸ‘‰ If the inorder traversal isn't strictly increasing, the tree isn't a valid BST.

---

## ğŸŒ² 2. **Preorder Traversal** (`Root â†’ Left â†’ Right`)

### ğŸ”§ How it works:

* Visit the node first.
* Then left, then right.

### ğŸ§  Use cases:

* **Clone or copy a tree**
  ğŸ‘‰ You want to record the structure (whatâ€™s the root, then whatâ€™s in the left, etc.).
* **Serialize a tree (save it to a file or string)**
  ğŸ‘‰ It gives you the root first so you can recreate the structure.
* **Prefix notation** for expression trees
  ğŸ‘‰ For example: `+ 3 * 4 5` instead of `3 + (4 * 5)`

---

## ğŸ 3. **Postorder Traversal** (`Left â†’ Right â†’ Root`)

### ğŸ”§ How it works:

* Visit both children before the node itself.

### ğŸ§  Use cases:

* **Safely delete or free a tree**
  ğŸ‘‰ You delete children before the parent, avoiding dangling references.
* **Evaluate expression trees**
  ğŸ‘‰ For example: `3 4 5 * +` (postfix/RPN notation).
* **Calculate values that depend on subtrees**
  ğŸ‘‰ E.g., total size of a directory (like in your `disk_usage` function).

---

## ğŸ§­ 4. **Breadth-First Search (BFS / Level Order Traversal)**

### ğŸ”§ How it works:

* Visits nodes **level by level** from top to bottom, left to right.

### ğŸ§  Use cases:

* **Finding the shortest path** in an unweighted tree/graph
  ğŸ‘‰ Because it visits levels in order of proximity to the root.
* **Checking completeness of a binary tree**
  ğŸ‘‰ You can see if all levels except maybe the last are full, and last is left-aligned.
* **Printing a tree by levels**
  ğŸ‘‰ Great for visualization or user-facing output.

---

## TL;DR Decision Table

| Traversal   | Order               | Good for...                                  |
| ----------- | ------------------- | -------------------------------------------- |
| Inorder     | Left â†’ Root â†’ Right | **Sorted BST values**, checking BST property |
| Preorder    | Root â†’ Left â†’ Right | Cloning, serializing, prefix expressions     |
| Postorder   | Left â†’ Right â†’ Root | Deleting, evaluating postfix expressions     |
| BFS (Level) | Level-by-level      | Shortest path, completeness, visualizing     |

