# 📌 Trees vs. Linear Structures

* Linear structures: one-dimensional (lists, arrays).
* Trees: **hierarchical**, support **branching**, and model natural structures like file systems and inheritance.

---

### 🌳 **Terminology Recap**

| Term                     | Meaning                                       |
| ------------------------ | --------------------------------------------- |
| **Root**                 | Topmost node, no parent.                      |
| **Parent/Child**         | Direct relationship; child has only 1 parent. |
| **Siblings**             | Nodes with same parent.                       |
| **Leaf (External Node)** | No children.                                  |
| **Internal Node**        | Has children.                                 |
| **Subtree**              | Any node and all its descendants.             |
| **Edge**                 | Link between parent and child.                |
| **Path**                 | Sequence of edges.                            |
| **Depth(p)**             | Edges from root to `p`.                       |
| **Height(p)**            | Longest path from `p` to a leaf.              |

> 🔁 *Depth is how far a node is from the root. Height is how far a node is from the leaves.*

---

### 🧱 **Tree ADT & Python Implementation**

Using **Position** objects to abstract nodes is key.

* Example accessor:

  ```py
  T.parent(p)  # returns the parent of p
  T.children(p)  # iterable of p’s children
  T.is_leaf(p)  # True if p has no children
  ```

* Example concrete helper:

  ```py
  def is_root(self, p):
      return self.root() == p
  ```

> These make traversal & manipulation more intuitive and maintain abstraction.

---

### ⏫ **Depth & Height**

* **Depth(p)**: recursive, `O(d_p)`

  ```py
  def depth(self, p):
      if self.is_root(p):
          return 0
      else:
          return 1 + self.depth(self.parent(p))
  ```

* **Height(p)**: recursive, max over all child heights

  ```py
  def height(self, p):
      if self.is_leaf(p):
          return 0
      else:
          return 1 + max(self.height(c) for c in self.children(p))
  ```

---

### 🌲 **Binary Trees**

* **Binary Tree**: max 2 children (left/right).
* **Proper (Full)**: 0 or 2 children.
* **Complete**: balanced and filled left to right.

Python ADT:

```py
t.left(p)
t.right(p)
t.sibling(p)
```

> `children(p)` in BinaryTree returns left and right (if they exist), in order.

---

### 🧬 **LinkedBinaryTree (Concrete Implementation)**

Private `_Node` class + public `Position` abstraction.

Setter methods include:

```py
T.add_root(e)
T.add_left(p, e)
T.add_right(p, e)
T.replace(p, e)
T.delete(p)
T.attach(p, T1, T2)
```

> Efficient (`O(1)`) and modifies structure safely.

---

### 📚 **Tree Traversal Algorithms**

All `O(n)` because every node must be visited.

#### 🔁 Preorder

* Visit node, then children recursively (root first).

#### 🔁 Postorder

* Visit children first, then the node (root last).

#### 🔁 Breadth-First (Level-order)

* Use a queue. Traverse all nodes at each depth before going deeper.

#### 🔁 Inorder (Binary Trees only)

* Left, Node, Right.
* Used in **Binary Search Trees** to get sorted order.

---

### 🧠 **Binary Search Tree (BST)**

* BST invariant: `left < node < right`
* Traversal used for search decisions: go left or right.
* Performance: O(height) — which could be bad if unbalanced (like a linked list).

---

### 🧵 **Implementing Traversals in Python**

Use generator methods:

```py
def preorder(self):
    yield from self._preorder_subtree(self.root())

def _preorder_subtree(self, p):
    yield p
    for c in self.children(p):
        yield from self._preorder_subtree(c)
```

---
