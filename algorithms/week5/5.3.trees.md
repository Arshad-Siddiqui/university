# Trees!

## The waffle sesh
Some dude said thinking nonlinearly is where breakthroughs happen. This is true with data structures as Trees have enabled us some very efficient algorithms that wouldn't be possible on an array for instance.

By nonlinear instead of just describing data as before or after we can describe them as adjacent or branching. Overall just **richer** than linear data types.

## The end of the waffle sesh
Trees also naturally represent data for certain structures. Such as how a website is organised down to its pages, GUIs, databases and file systems.

- They store data **hierarchically** instead of linearly.
- Language used to describe node relationships are **parent/child** and **descendent/ancestor**.
- Aside from the **root** node, all nodes have parents and 0 or more children.

- Trees can be empty where they have no nodes.
- Nodes that have the same parent node are **siblings**
- **Internal** nodes have children and **external** nodes do not.
- Extenal nodes are sometimes called **leaves**.

- Subtrees are located within trees. To describe a subtree you'd describe it's root. 'Subtree rooted at directory A'
- **Edges** of a tree are the relationship between a parent and child. Contains 2 nodes that are directly related.
- **Paths** are made of edges. Think of edges like roads and paths like the collection of roads that make routes.
- **height** of a node is the number of edges between the route and it. Or how many edges in the path from that element to the route.

## Tree representation
![Diagram representing a tree with 17 nodes](image.png)
- Nodes represented by rectangles or ovals.
- Edges represented by the lines between these nodes.

## Tree formal definition

A set of nodes holding elements that are stored with parent child relationships.

- For a nonempty tree there is a special node called the root of T which has no parent.
- Each node (that isn't the root) of the tree only has 1 parent.

## Ancestor definition

A node can be an ancestor of itself and anything above it is an ancestor.

We can reverse this to define a descendant. So if node A is ancestor of node B then node B is node A's descendant.

## Edges and Paths

An edge is a pair of nodes that have a direct parent child relationship. A path is made up **completely** of interconnected edges. No jumps allowed.

> The book uses some goofy ah example using recursive definitions I found difficult to think about.

## General Tree example

Python class inheritance forms a tree

![Example showing hierarchy of python classes.](image-1.png)

Above image shows just the branch with all the exception types. The BaseException class is what everything and all the user defined exceptions are built off of.

## Ordered Trees
A tree is ordered if the children of the nodes are in a meaningful order. This requires the children can be identified to be in a particular order.

An example is a family tree where sibling nodes are organised based on age.

This is normally visualised by placing the elements left to right.

      |root|
    /    |     \
   /     |      \
|child1||child2||child3|

In a binary tree where each node has 2 children, they would be stored as either **left** or **right**.

## Tree abstract data type

We use a **position** to abstract a node of a tree. An element is stored per position and the positions satisfy parent-child relationship.

Position is preferred to just 'node' as we're trying to hide the implementation and want the user to think of it as just positions and elements.

This position object has 1 method.

> **'p'** is the position object and **'T'** is the tree object.

`p.element()`

- This clearly just returns the element stored at that position.

The tree ADT has the following **accessor methods** in order to navigate the tree.

```py
T.root()
# Returns position for root of T
# or non if tree is empty
T.is_root(p)
# Takes a position and return True if
# it is the root of T.
T.parent(p)
# Returns position of parent of p
T.num_children(p)
# Returns the number of children of position P
T.children(p)
# Creates an iterable for the children of p.
T.is_leaf(p)
# Returns true if p has no children
len(T)
# Return the number of positions within T
T.is_empty(p)
T.positions(p)
# Generates iterable for all positions
iter(T)
# Generates iterable for all elements stored in the tree.
```
- For the above if an incorrect position is given as an argument it generates a ValueError.
- If the tree is ordered then T.children(p) gives the children in correct order.

> Note how the methods above do not offer any way to modify the tree. This comes later in the book.

## Keeping a Tree Abstract Base Class

We'll be making loads of types of trees so keeping a base class with the general methods will allow greater code reuse.

We could just go into making a **concrete** python class **without** this abstract one to build off of. However when we need to build another concrete python class we would probably have to redefine some methods.

```py
class Tree:
    class Position:
        def element(self):
            # returns the element of this position
        def __eq__(self, other):
            # If other points to the same position then we return True
        def __ne__(self, other):
            # inverse of above.
    #------[end of position class]------

    # These methods below must be implemented
    # by any subclass. In this base class each one
    # should raise an error if not implemented.

    # e.g. raiseNotImplementedError(
    # 'must be implemented')

    def root(self):
        # Returns position of root.
        # None if empty

    def parent(self, p)
        # Returns position of parent of
        # given position
    
    def num_children(self, p):
        # Returns number of children of
        # position p

    def children(self, p)
        # Returns iterable containing all
        # child positions of p
    def __len__(self):
        # Returns the number of elements in 
        # the tree

    # ---[Concreete methods implemented here]---
    def is_root(self, p)
        # True if the position represents the root.
        return self.root() == p
    def is_leaf(self, p)
        # True if the position has no children.
        return p.num_children == 0
    def is_empty(self)
        # True if the tree is empty.
        return len(self) == 0
```
## 8.1.3 Computing Depth and Height

Depth refers to the number of ancestors excluding the position in question. (As positions are their own ancestors but in this case we ignore)

T has a depth of 0

### Depth defined

- If position p is the root then it has a depth of 0.
- The child of a position has +1 the depth of its parent.

We can use both parts of the definition to create amethod

```py
def depth(self, p):
    if self.is_root(p)
        return 0
    else:
        return 1 + self.depth(self.parent(p))
        # Recursive loop keeps asking if parent
        # is the root and adds 1 each time
```
Has time complexity of O(n). This is because in the worst case all the elements are aligned linearly and we have to run through each position to find the root.

However it is more descriptive to state running time in terms of d~p~ which denoteas depth of the position in the tree. This is because the depth can be a lot smaller than the number of elements in the tree.

O(d~p~ + 1) -> They don't really explain where that + 1 comes from but I'm not upset.

### Height defined
If position p is a leaf then the height of p is 0. Otherwise the height of p is one more than it's children.

The height of a nonempty tree is the height of the root.

Height and depth are like the opposite of each other. So the root of the tree has the least depth but the greatest height. 

## Binary Tree
- Ordered tree where each parent has no more than 2 children.
- Children are sorted left and right. A left child has precedence over a right child.
- If these children are subtrees then we call them left and right subtree of that node.
- In proper binary trees, each node only has 0 or 2 children. A tree where a node has 1 element is called an improper tree.

### Python ADT

Because trees are abstract data types in python we have to define functions for it. With a binary tree we have a few more valid options.

T -> Tree class
t is instance

t.left -> gives the left child
t.right -> gives the right child,
t.sibling -> gives the sibling node or None if non-existant.

![Example of binary tree](/algorithms/week5/Screenshot%202025-06-08%20at%2016.28.14.png)

We can see that as we add levels to binary tree the max number of nodes grows exponentially. Could potentially do some cool maths with it.

> I did kinda skip some sections that got kinda heavy.

## Reading 8.3: Implementing Trees

### Linked structure for Binary Tree

- This node references the element stored as well as children and parent.
- If it has no parent (it is the root) then it stores None at the parent field.
- If a left or right child is missing then it stores None on them too.

- The actual tree class (not node) stores a reference to the root and also a size variable that represents the number of nodes attached.

### Doing an implementation

Overall the book, a chapter back, implemented a regular Tree class. They later subclassed out a binary tree ADT in this section. They basically built on top of it. The class was called LinkedBinaryTree that internally holds a Tree class instance.

Their implementation had a hidden _Node class. They then used a public Position class to present the node.

### Array based implementation

