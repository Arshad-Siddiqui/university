# 📌 Trees vs. Linear Structures

* Linear structures: one-dimensional (lists, arrays).
* Trees: **hierarchical**, support **branching**, and model natural structures like file systems and inheritance.

---

### 🌳 **Terminology Recap**

| Term                     | Meaning                                       |
| ------------------------ | --------------------------------------------- |
| **Root**                 | Topmost node, no parent.                      |
| **Parent/Child**         | Direct relationship; child has only 1 parent. |
| **Siblings**             | Nodes with same parent.                       |
| **Leaf (External Node)** | No children.                                  |
| **Internal Node**        | Has children.                                 |
| **Subtree**              | Any node and all its descendants.             |
| **Edge**                 | Link between parent and child.                |
| **Path**                 | Sequence of edges.                            |
| **Depth(p)**             | Edges from root to `p`.                       |
| **Height(p)**            | Longest path from `p` to a leaf.              |

> 🔁 *Depth is how far a node is from the root. Height is how far a node is from the leaves.*

---

### 🧱 **Tree ADT & Python Implementation**

Using **Position** objects to abstract nodes is key.

* Example accessor:

  ```py
  T.parent(p)  # returns the parent of p
  T.children(p)  # iterable of p’s children
  T.is_leaf(p)  # True if p has no children
  ```

* Example concrete helper:

  ```py
  def is_root(self, p):
      return self.root() == p
  ```

> These make traversal & manipulation more intuitive and maintain abstraction.

---

### ⏫ **Depth & Height**

* **Depth(p)**: recursive, `O(d_p)`

  ```py
  def depth(self, p):
      if self.is_root(p):
          return 0
      else:
          return 1 + self.depth(self.parent(p))
  ```

* **Height(p)**: recursive, max over all child heights

  ```py
  def height(self, p):
      if self.is_leaf(p):
          return 0
      else:
          return 1 + max(self.height(c) for c in self.children(p))
  ```

---

### 🌲 **Binary Trees**

* **Binary Tree**: max 2 children (left/right).
* **Proper (Full)**: 0 or 2 children.
* **Complete**: balanced and filled left to right.

Python ADT:

```py
t.left(p)
t.right(p)
t.sibling(p)
```

> `children(p)` in BinaryTree returns left and right (if they exist), in order.

---

### 🧬 **LinkedBinaryTree (Concrete Implementation)**

Private `_Node` class + public `Position` abstraction.

Setter methods include:

```py
T.add_root(e)
T.add_left(p, e)
T.add_right(p, e)
T.replace(p, e)
T.delete(p)
T.attach(p, T1, T2)
```

> Efficient (`O(1)`) and modifies structure safely.

---

### 📚 **Tree Traversal Algorithms**

All `O(n)` because every node must be visited.

#### 🔁 Preorder

* Visit node, then children recursively (root first).

#### 🔁 Postorder

* Visit children first, then the node (root last).

#### 🔁 Breadth-First (Level-order)

* Use a queue. Traverse all nodes at each depth before going deeper.

#### 🔁 Inorder (Binary Trees only)

* Left, Node, Right.
* Used in **Binary Search Trees** to get sorted order.

---

### 🧠 **Binary Search Tree (BST)**

* BST invariant: `left < node < right`
* Traversal used for search decisions: go left or right.
* Performance: O(height) — which could be bad if unbalanced (like a linked list).

---

### 🧵 **Implementing Traversals in Python**

Use generator methods:

```py
def preorder(self):
    yield from self._preorder_subtree(self.root())

def _preorder_subtree(self, p):
    yield p
    for c in self.children(p):
        yield from self._preorder_subtree(c)
```

# Traversal explanations

## 🌱 1. **Inorder Traversal** (`Left → Root → Right`)

### 🔧 How it works:

* Goes as far left as possible.
* Then visits the node.
* Then explores the right subtree.

### 🧠 Use cases:

* **Sorted output of a Binary Search Tree (BST)**
  👉 This is the *most common use case*. Inorder traversal of a BST gives nodes **in ascending order**.
* **Check if a tree is a BST**
  👉 If the inorder traversal isn't strictly increasing, the tree isn't a valid BST.

---

## 🌲 2. **Preorder Traversal** (`Root → Left → Right`)

### 🔧 How it works:

* Visit the node first.
* Then left, then right.

### 🧠 Use cases:

* **Clone or copy a tree**
  👉 You want to record the structure (what’s the root, then what’s in the left, etc.).
* **Serialize a tree (save it to a file or string)**
  👉 It gives you the root first so you can recreate the structure.
* **Prefix notation** for expression trees
  👉 For example: `+ 3 * 4 5` instead of `3 + (4 * 5)`

---

## 🍁 3. **Postorder Traversal** (`Left → Right → Root`)

### 🔧 How it works:

* Visit both children before the node itself.

### 🧠 Use cases:

* **Safely delete or free a tree**
  👉 You delete children before the parent, avoiding dangling references.
* **Evaluate expression trees**
  👉 For example: `3 4 5 * +` (postfix/RPN notation).
* **Calculate values that depend on subtrees**
  👉 E.g., total size of a directory (like in your `disk_usage` function).

---

## 🧭 4. **Breadth-First Search (BFS / Level Order Traversal)**

### 🔧 How it works:

* Visits nodes **level by level** from top to bottom, left to right.

### 🧠 Use cases:

* **Finding the shortest path** in an unweighted tree/graph
  👉 Because it visits levels in order of proximity to the root.
* **Checking completeness of a binary tree**
  👉 You can see if all levels except maybe the last are full, and last is left-aligned.
* **Printing a tree by levels**
  👉 Great for visualization or user-facing output.

---

## TL;DR Decision Table

| Traversal   | Order               | Good for...                                  |
| ----------- | ------------------- | -------------------------------------------- |
| Inorder     | Left → Root → Right | **Sorted BST values**, checking BST property |
| Preorder    | Root → Left → Right | Cloning, serializing, prefix expressions     |
| Postorder   | Left → Right → Root | Deleting, evaluating postfix expressions     |
| BFS (Level) | Level-by-level      | Shortest path, completeness, visualizing     |

