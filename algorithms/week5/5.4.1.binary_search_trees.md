# Binary Search Trees (BSTs) Summary & Deep Dive

## Overview

Binary Search Trees are data structures that store key-value pairs in a sorted, hierarchical manner, offering efficient search, insertion, and deletion operations when balanced.

---

## Comparison: BSTs vs Sorted Arrays

| Feature             | Binary Tree (e.g. BST)              | Array (Sorted)             |
| ------------------- | ----------------------------------- | -------------------------- |
| **Search Time**     | `O(log n)` (balanced)               | `O(log n)`                 |
| **Insertion Time**  | `O(log n)` (balanced), `O(n)` worst | `O(n)` (shifting required) |
| **Deletion Time**   | `O(log n)` (balanced)               | `O(n)`                     |
| **Memory Usage**    | Higher (due to node pointers)       | Lower (contiguous block)   |
| **Structure**       | Dynamic (grows/shrinks easily)      | Static or semi-dynamic     |
| **Access by Index** | `O(n)` (in-order traversal)         | `O(1)` (direct indexing)   |
| **Maintains Order** | Yes (via in-order traversal)        | Yes                        |

---

## BST Key Operations

### Search (`__getitem__`)

* Traverse from root.
* Go left if target key < current.
* Go right if target key > current.
* Time Complexity: `O(h)` (h = height of tree).

### Insert (`__setitem__`)

1. Search for the key.
2. If it exists: update value.
3. If not: insert at the leaf where search fails.

* Time Complexity: `O(h)`

### Delete (`__delitem__`)

* **0 or 1 Child**: Remove node and promote its child (if any).
* **2 Children**:

  1. Find in-order predecessor (rightmost of left subtree).
  2. Replace target with predecessor.
  3. Recursively delete predecessor.

---

## Tree Traversals

| Type        | Order                | Typical Use Case                         |
| ----------- | -------------------- | ---------------------------------------- |
| In-order    | Left → Root → Right  | Get sorted order of keys                 |
| Pre-order   | Root → Left → Right  | Tree cloning, expression prefix notation |
| Post-order  | Left → Right → Root  | Deleting/freeing tree (bottom-up)        |
| Level-order | BFS (layer by layer) | Serialization, closest-path search       |

### In-order Traversal

* Used for sorting: outputs keys in ascending order.
* Recursive: Traverse left subtree → Visit node → Traverse right subtree.

### Post-order Traversal

* Used for cleanup (e.g., memory deallocation).
* Recursive: Visit children first, then the node.
* Last visited node is the root.

---

## Performance and Tree Shape

* BST operations are `O(h)` where `h` is the height.
* **Balanced Tree**: `h = log n` → optimal performance.
* **Unbalanced Tree**: `h = n` → degenerates into a linked list.
* Worst case happens with sorted input (e.g., inserting 1, 2, 3...)

### Balanced BSTs (e.g., AVL, Red-Black Trees)

* Self-balancing to ensure height stays logarithmic.
* Necessary for maintaining performance guarantees in dynamic systems.

---

## Extras

### find\_range(start, stop)

* Return all keys in a sorted range.

### find\_gt(k)

* Find the smallest key greater than k.

### first(), last(), before(p), after(p)

* Navigate the sorted structure efficiently using BST properties.

---

## Recommendations for Further Study

* **AVL Trees or Red-Black Trees**: Understand automatic balancing.
* **5.4.2 BST Visualization**: (link broken) Worth revisiting as an interactive tool.
* **Recursive vs Iterative Implementations**: Good for grasping control flow.

---

## Summary

Binary Search Trees provide a powerful and efficient way to manage ordered data, especially when modifications (inserts, deletes) are frequent. While they use more memory than arrays, their dynamic nature and support for efficient range queries and sorted iteration make them ideal for implementing maps and sets in many real-world systems.
