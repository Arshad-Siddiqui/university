# Introduction

- Recursion
- Trees
- Binary search trees
- Maps
- Sets
- Hash tables

# 5.2 Recursion

Functions, recursive or not, when called produce a structure called a frame to store information about that particular function call. They typically store data such as its namespace, parameters, local variables and also which command in the body it is running.

This gets halted when a nested function call is made and the frame records where to pick back off after that nested function call is finished executing. There is a **different** frame for each function call even if it was for the same one.

## Reading

### Analysing recursive functions

#### Computing factorials

5! = 5 x 4 x 3 x 2 x 1 = 120

Pretty easy to turn this into an algorithm using recursion

```py
def factorialise(value):
  if value == 0
    return 1
  return value * factorialise(value - 1)
```
##### Code analysis

- We call the function from within the function but with a different argument.
- There's that guard clause to stop us calling the function forever.
- This could have easily been implemented with a loop and there's **no** particular advantage for choosing recursion over it.

##### Algorithm analysis

- There are n + 1 activations of our function. (n + 1 because we're calling it from n -> 0)
- Ignoring constants we're left with **O(n)**.

#### Drawing an English Ruler

Fractals for babies. Fractal in the sense that at different levels of magnification the structure repeats itself. power of 10s

We could represent the lines on a ruler using '-' where the more significant values are longer '---' and they get shorter at the mid points and the mid points of those mid points.
```
--- 3
-
--
-
--- 2
-
--
-
--- 1
-
--
-
--- 0
```

> I did prety [good!](/algorithms/week5/python_/english_ruler.py)

#### Binary Search

When data is sorted you can cut the search pool in half each step making it way more efficient than going through every single element and checking it off the list in the worst case. We're looking at O(log n) instead of O(n).

Searching through a billion elements only takes 30 steps ;)

