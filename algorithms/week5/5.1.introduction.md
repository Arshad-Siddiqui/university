Here's a polished and structured version of your notes on **Recursion** and related concepts from your Week 5 reading. I've cleaned up phrasing, added clarity, and preserved all the depth and humor from your original notes while making it easier to review or share.

---

# 📚 Week 5 – Recursion & Friends

## 🔄 Introduction

This week's content revolves around recursive thinking and structures that naturally lend themselves to recursion:

* Recursion
* Trees
* Binary Search Trees
* Maps
* Sets
* Hash Tables

---

## 🔁 5.2 Recursion

### 🔧 How Recursive Functions Work

Every function call creates a **stack frame**, which contains:

* The function’s namespace (its local variables)
* Parameters
* The current line being executed

When a function calls another (or itself), the current frame is **paused** and a new frame is added on top of the **call stack**.

A recursive function **without a base case** results in a **stack overflow** as the call stack keeps growing infinitely.

---

## 🧠 Understanding Recursion Through Examples

### ✅ Factorial (Classic Example)

```py
def factorialise(value):
  if value == 0:
    return 1
  return value * factorialise(value - 1)
```

**Concepts:**

* The recursive call is made with a different argument (`value - 1`)
* Has a **base case** to stop infinite recursion

**Analysis:**

* Function is called `n + 1` times (from `n` down to `0`)
* Each operation is O(1)
* **Overall time complexity: O(n)**

---

### 📏 Drawing an English Ruler

Recursive, fractal-like problem: drawing ruler ticks at varying lengths.

* Longest tick at the major divisions (inches, centimeters, etc.)
* Midpoints have shorter ticks, and recursively more midpoints

🔁 Recursive behavior: at each level, the function draws:

* Left half (recursive)
* A center tick
* Right half (recursive)

**Lines printed:** \~ `2^c - 1` where `c` is the number of recursive levels

---

### 🔍 Binary Search (Efficient Searching)

* Requires sorted, indexable data
* Each recursive step cuts the search pool in half
* **Time complexity: O(log n)**
  Even searching a billion items takes only \~30 steps!

---

### 💽 Recursive Disk Usage (File Systems)

You can use recursion to calculate total disk usage by navigating subdirectories.

**Pseudocode:**

```py
def disk_usage(path):
  total = size_of(path)
  if path is directory:
    for file in list_dir(path):
      total += disk_usage(file)
  return total
```

* Top-down accumulation
* Recursive tree-walking
* Mirrors `du` command in Unix/Linux

---

## ⚠️ Bad Recursion (When Recursion Goes Wrong)

All recursive logic can technically be rewritten iteratively. **Bad recursion = poor design**, not recursion itself.

---

### ❌ Unique Element Problem (Terrible Recursion Example)

```py
def unique3(S, start, stop):
  if stop - start <= 1:
      return True
  elif not unique3(S, start, stop - 1):
      return False
  elif not unique3(S, start + 1, stop):
      return False
  else:
      return S[start] != S[stop - 1]
```

**Why it’s bad:**

* Each frame calls the function **twice**
* **Time complexity: O(2^n)** – terrible!

💡 *Could be fixed with memoization*

---

### 🌀 Fibonacci Numbers

Recursive Fibonacci is a textbook example of good vs bad recursion.

#### Bad Fibonacci

```py
def bad_fibonacci(n):
  if n <= 1:
    return n
  return bad_fibonacci(n - 1) + bad_fibonacci(n - 2)
```

* Each call spawns **two more calls**
* **Time complexity: O(2^n)** – exponential!

---

#### ✅ Good Fibonacci (Linear Recursion)

```py
def good_fibonacci(n):
  if n == 0:
    return (0, 1)
  else:
    a, b = good_fibonacci(n - 1)
    return (b, a + b)
```

* Only one recursive call per frame
* **Time complexity: O(n)** – way better!

---

## 🚧 Recursion Limits

* Python’s default recursion limit is **1000**
* You can modify it with `sys.setrecursionlimit()`, but be cautious!

---

## 🧱 More Recursive Structures

### Recursion Types

* **Linear Recursion**: Each call makes one recursive call (e.g., `factorial`)
* **Binary Recursion**: Each call makes two recursive calls (e.g., bad Fibonacci)
* **Multiple Recursion**: More than two recursive calls per frame (e.g., permutations)

### Binary Search ≠ Binary Recursion

Even though binary search splits the data, it only ever recurses **once per frame** (never both branches), so it’s still linear recursion. Time complexity: **O(log n)**.

---

## 🧪 Designing Recursive Functions

Tips:

1. Always define a **base case**
2. Make sure recursive calls **move toward that base case**
3. Add **memoization** to avoid re-computing values unnecessarily

---

## 🧠 Memoization

Use memoization to:

* Save previous results
* Avoid recomputation
* Reduce time complexity

Great for:

* Fibonacci
* Dynamic programming problems
* Anything with overlapping subproblems

---

## 📖 Recap

| Concept               | Key Idea                             |
| --------------------- | ------------------------------------ |
| Stack Frames          | Store function call context          |
| Base Case             | Prevents infinite recursion          |
| Binary Search         | Efficient recursive search: O(log n) |
| Disk Usage            | Recursively explore directories      |
| Bad Recursion         | Leads to exponential time            |
| Good Fibonacci        | Returns tuples to keep it linear     |
| Memoization           | Speed up recursion using memory      |
| Recursion Depth Limit | Python default: 1000                 |

---

Let me know if you want flashcards, a summary PDF, or coding exercises based on this!
