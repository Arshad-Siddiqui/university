# üìò Red-Black Trees

> Based on Section 11.6 from *Data Structures and Algorithms in Python*
>
> * Notes from YouTube: [William Fiset's Red-Black Tree Playlist](https://www.youtube.com/watch?v=5IBxA-bZZH8)

---

## üî¥‚ö´ What is a Red-Black Tree?

A **Red-Black Tree (RBT)** is a type of **self-balancing Binary Search Tree (BST)** that guarantees **O(log n)** time complexity for operations like:

* Insertion
* Deletion
* Search

Like all BSTs, red-black trees maintain elements in **sorted order**, but they introduce a few rules to control the **tree's height**, which helps avoid the worst-case (unbalanced) scenarios of a standard BST.

### üîß Why Use a Red-Black Tree?

RBTs strike a balance between fast operations and low memory/storage overhead.
You‚Äôll often find them used in:

* **Databases** (e.g., for indexing)
* **File systems** (e.g., Linux‚Äôs ext3/4 uses them internally)
* **Java‚Äôs TreeMap**, **C++ STL‚Äôs `map`**, and other sorted maps
* **Memory allocators**

Compared to **AVL Trees**, RBTs:

* Do **slightly fewer rebalancing steps**
* Are **faster** for insertion-heavy workloads
* Provide **"good enough" balancing** to maintain `O(log n)` operations

---

## üå≤ Red-Black Tree Properties

Each node in the tree is either **red** or **black**. To maintain balance, the following rules must always be true:

### üîó The 5 Red-Black Tree Rules:

1. **Node Color**: Every node is either red or black.
2. **Root Rule**: The root is always black.
3. **Leaf Rule**: All leaves (`NIL`/null pointers) are considered black. (Not in the diagram below but each node with missing children actually has a nil node there that's a black leaf. It is just usually omitted for clarity)
4. **Red Rule**: A red node cannot have a red child. (No two reds in a row.)
5. **Black Depth Rule**: Every path from a node to its descendant `NIL` leaves must contain the **same number of black nodes** (aka **black height**).

> ‚úÖ These rules ensure the longest path from root to leaf is no more than **twice as long** as the shortest, ensuring O(log n) height.

---

## üß† Example (Analysis)

![Red Black Tree](image-12.png)

* The **root** is black.
* Red node `10` has only black children ‚Üí ‚úÖ Red Rule.
* Leaves `3`, `4`, `6`, `8`, `11`, `13`, `14`, `17` have the **same black depth** of 2 (excluding root) ‚Üí ‚úÖ Black Depth Rule.

---

## üß© Tree Height Intuition

* **Shortest path** (to a leaf): all **black** nodes.
* **Longest path**: alternating **red-black-red...**, but still only **2√ó shorter path** at most.

This balance ensures that the tree height is always **O(log n)** in the number of nodes.

---

## ‚öôÔ∏è Red-Black Tree Operations

### üîç Searching

Exactly the same as in a BST:

* Start at the root
* Compare key
* Traverse left or right

Time complexity: **O(h)**, where h is the tree height ‚Üí for RBTs, **O(log n)**.

---

### ‚ûï Insertion

1. Insert the new node like in a BST ‚Äî at the **correct position** using a search.
2. **Color the new node red** (unless it's the root, then it‚Äôs black).
3. **Fix any violations** (e.g., if the parent is red ‚Üí violates the Red Rule).

> Fixes are done through **recoloring** and **rotations**, which are both **O(1)** operations.

#### üéØ Why insert red?

* Avoids increasing the black depth.
* Easier to repair with local adjustments.

---

### üîÅ Tree Rotations

Used to fix violations and rebalance the tree. Rotations are **structure-preserving** (they don't break the BST invariant).

#### üîÑ Left Rotation

Moves a node down to the left, and its right child moves up.

```
Before:
     5
      \
      10
     /
    8

After left rotate at 5:
     10
     /
    5
     \
      8
```

#### ‚Ü©Ô∏è Right Rotation

The inverse of left rotation. Moves a node down to the right.

```
Before:
     10
     /
    5
     \
      8

After right rotate at 10:
     5
      \
      10
     /
    8
```

---

### ‚ùó Fixing Double Red Violations

If you insert a red node under a red parent ‚Üí breaks Red Rule.

#### How to fix:

* **Case 1: Uncle is red** ‚Üí Recolor parent, uncle, and grandparent.
* **Case 2: Uncle is black** ‚Üí Rotate and recolor.

> These cases are handled recursively up the tree until all rules are satisfied.

---

## üß® Deletion (Optional Preview)

Deletion is more complex due to preserving all RBT rules. It often results in **extra black depth** violations which need to be fixed with:

* Recoloring
* Rotations
* "Pushing" blackness around the tree

---

## üóÇÔ∏è Summary Table

| Operation | Time Complexity | Notes                         |
| --------- | --------------- | ----------------------------- |
| Search    | `O(log n)`      | Same as balanced BST          |
| Insert    | `O(log n)`      | Rotations + recolor if needed |
| Delete    | `O(log n)`      | More complex fix-up needed    |
| Space     | `O(n)`          | 1 bit extra per node (color)  |

---

## üß™ Key Takeaways

* Red-Black Trees are efficient and practical for sorted maps & sets.
* Maintain **near-perfect balance** with **minimal overhead**.
* Compared to AVL trees: slower lookup, faster insert/delete.

**AVL trees** are like Red and Black trees in that they're self balancing but just work slightly differently.
