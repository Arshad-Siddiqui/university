# 14.1 📘 Graphs

In computer science, a **graph** models relationships between entities. Unlike the graphs used in statistics (like bar charts or line graphs), these graphs consist of **vertices** and **edges**, and are a fundamental concept in data structures and algorithms.

---

### ✅ Basic Terminology

* **Graph `G`**: A structure consisting of:

  * A set of **vertices** `V` (also called **nodes**).
  * A set of **edges** `E` (also called **arcs**).

```
G = (V, E)
```

* **Edge (u, v)**: A connection between two vertices `u` and `v`.

---

### 🔄 Edge Direction

* **Undirected Graph**:

  * Edges **do not** have a direction.
  * `(u, v)` is the **same** as `(v, u)`.
  * Usually represented with a **line**:
    `u —— v`

* **Directed Graph (Digraph)**:

  * Edges **have a direction**.
  * `(u, v)` means an edge **from `u` to `v`**.
  * Represented with an **arrow**:
    `u → v`

* **Mixed Graph**:

  * Contains **both** directed and undirected edges.
  * Not commonly used, but can represent complex systems.

> ℹ️ It's technically possible to convert an undirected graph into a directed one by replacing each undirected edge `(u, v)` with **two** directed edges: `(u, v)` and `(v, u)`. However, this adds unnecessary complexity and reduces clarity.

---

### 🧮 Degree of a Vertex

* **Degree**: Number of edges connected to a vertex.
* In **directed graphs**, this splits into:

  * **In-degree**: Number of incoming edges.
  * **Out-degree**: Number of outgoing edges.

---

### ⚠️ Simple Graphs

A **simple graph**:

* Has **no parallel edges**:

  * No multiple edges between the same pair of vertices.
* Has **no self-loops**:

  * No edge that connects a vertex to itself.

> A simple graph uses a **set** for its edges, ensuring no duplicates.

---

### 🔁 Parallel Edges and Use Cases

While **not allowed** in simple graphs, parallel edges are useful in **multigraphs**. For instance:

* **Flights between two airports** may have different:

  * Times
  * Prices
  * Routes

Each can be represented as a separate edge with different **weights**.

---

### 📍 Paths and Cycles

* **Path**: A sequence of vertices and connecting edges, with no jumps or backward travel.

* **Cycle**: A path that **starts and ends** at the **same vertex**.

  * Must contain **at least one edge**.

* **Simple Path**: All vertices (except possibly the first and last) are distinct.

* **Simple Cycle**: Same as a simple path, but allows repetition of the first/last vertex.

* A graph is **acyclic** if it contains **no cycles**.

  * In a **DAG (Directed Acyclic Graph)**, once you leave a node, there's **no way back**.

---

## 🔍 Reachability

* In a **directed graph**, vertex `u` **reaches** vertex `v` if there's a **directed path** from `u` to `v`.

> ⚠️ This is **not symmetric** — `u → v` doesn't imply `v → u`.

* In an **undirected graph**, reachability **is symmetric**. If `u` can reach `v`, then `v` can reach `u`.

---

## 🔗 Connectivity

* A graph is **connected** if **every pair** of vertices has a path between them.

### In Directed Graphs:

* **Strongly Connected**:
  Every vertex can **reach every other vertex** through directed paths.

* **Weakly Connected**:
  If you replace all directed edges with undirected ones, the resulting graph is connected.

---

## 📦 Subgraphs

A **subgraph** is a graph formed from a subset of the **vertices** and **edges** of another graph.

* A **spanning subgraph** includes **all vertices** from the original graph, but may have **fewer edges**.

---

# 14.1.1 🧱 Graph ADT (Abstract Data Type)

To represent graphs in code, we usually define three classes:

1. **Vertex**:

   * Stores a value (like a label or data).
   * Often includes a reference to its position in a vertex list (for quick removal).

2. **Edge**:

   * Stores a value (such as weight).
   * Includes references to the two endpoints (vertices).
   * Has methods like `.origin()` and `.destination()` to access those endpoints.

3. **Graph**:

   * Manages collections of vertices and edges.
   * Provides methods to add, remove, and query edges and vertices.

> 😴 *If you're getting tired, now's a good time to read this in smaller chunks — but these structures are key to implementing real-world graphs efficiently.*

---

# 14.2.1 🧾 Edge List Structure

The **simplest** representation:

* Store vertices in one list.
* Store edges in a second list.
* Each edge stores references to its two endpoints.

![Edge list diagram](image-12.png)

---

### 💡 Performance

#### Space Complexity

* O(n + m), where:

  * `n` = number of vertices
  * `m` = number of edges

#### Time Complexity

| Operation                 | Time Complexity |
| ------------------------- | --------------- |
| Add Vertex                | O(1)            |
| Add Edge                  | O(1)            |
| Get All Vertices          | O(n)            |
| Get All Edges             | O(m)            |
| Search for Edge           | O(m)            |
| Delete Edge               | O(m)            |
| Delete Vertex (and edges) | O(m)            |

> Deleting a vertex requires checking **all edges** to remove any that are incident to it.

---

# 14.2.2 🪢 Adjacency List Structure

An improvement on the edge list.

Each vertex maintains a list (usually a **linked list**) of **incident edges** — those connected to it.

* For directed graphs:

  * Store **incoming** and **outgoing** edges separately.
* For undirected graphs:

  * One list per vertex is enough.

![Adjacency List Diagram](image-13.png)

---

### 💡 Performance

| Operation             | Time Complexity               |
| --------------------- | ----------------------------- |
| Space                 | O(n + m)                      |
| Add Vertex            | O(1)                          |
| Add Edge              | O(1)                          |
| Get Incident Edges    | O(deg(v))                     |
| Search for Edge       | O(deg(v))                     |
| Delete Vertex & Edges | O(deg(v)) + O(n) (worst case) |

> `deg(v)` = degree of vertex `v` (i.e., number of edges connected to it)

![Performance comparison table](image-14.png)

---

### ✅ Advantages over Edge List

* Much faster for:

  * Finding all incident edges
  * Calculating degree
  * Searching for a specific connection

---

> 🔎 Want extra credit? Look into **Adjacency Maps**, which use dictionaries instead of lists for even faster lookups in sparse graphs.

---

# 🧮 Adjacency Matrix Structure

Represents a graph as a `V x V` 2D array.

* Each cell `(i, j)` stores:

  * `1` if there's an edge from `i → j` (for unweighted)
  * Or a weight value (for weighted graphs)

### ⚙️ Properties

| Feature                | Performance          |
| ---------------------- | -------------------- |
| Space Complexity       | O(n²)                |
| Add Vertex             | O(n²) (resize array) |
| Add/Delete Edge        | O(1)                 |
| Check if Edge Exists   | O(1)                 |
| Iterate Over All Edges | O(n²)                |

> Good for **dense graphs**, but wasteful for **sparse graphs**.

# AI QnA

## A few questions about edge lists. How do we represent a vertex without edges? Also why is the space complexity O(n+m) when we're just recording edges?

Great questions — both are important to understand **why the edge list structure works the way it does** and what its limitations are.

---

### ❓ **1. How do we represent a vertex without edges in an edge list?**

In the **edge list representation**, **edges** are stored in one list, and **vertices** are stored in a **separate list**.

So, if a vertex has **no edges**, it's still present in the **vertex list**, just not referenced in any edge.

#### Example:

Let’s say we have this graph:

```
Vertices: A, B, C
Edges: (A, B)
```

This means:

* **Vertex list** = `[A, B, C]`
* **Edge list** = `[(A, B)]`

Here, vertex `C` has **no incident edges**, but it’s still present in the vertex list.

> So the vertex list is essential — without it, any vertex without an edge would be "invisible" to the data structure.

---

### ❓ **2. Why is the space complexity O(n + m) if we're mainly recording edges?**

You're right to question this — it might feel like we're mostly storing edges, but here's what happens under the hood:

#### Recall:

* `n` = number of **vertices**
* `m` = number of **edges**

In an edge list structure:

* We explicitly store **`n` vertex objects** in a list (or array).
* We also store **`m` edge objects** in a separate list.

Even though edges dominate in **dense graphs**, the **space used by vertices still matters**, especially in **sparse graphs** where `m << n²`.

### 📦 Space Breakdown:

| Component   | Storage Needed |
| ----------- | -------------- |
| Vertex list | O(n)           |
| Edge list   | O(m)           |
| **Total**   | O(n + m)       |

Each object (vertex or edge) is a reference in a list — so we’re talking about space for object references, not full adjacency tables or matrices.

> 🔁 Each edge also typically stores references to the two vertex objects it connects. But this doesn't change the overall complexity — we still count it as O(m) since each edge stores a constant number of values (typically 2 or 3, including weight).

---

### 📝 Summary

| Question                                     | Answer                                                                         |
| -------------------------------------------- | ------------------------------------------------------------------------------ |
| **How to represent a vertex without edges?** | By including it in the **vertex list**. It just won’t appear in the edge list. |
| **Why O(n + m) space complexity?**           | Because we store both the list of `n` vertices **and** the list of `m` edges.  |

Let me know if you’d like a visual diagram or comparison table of graph representations!
