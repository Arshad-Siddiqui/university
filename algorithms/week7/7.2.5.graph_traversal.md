# 📌 Graph Traversal

Graph traversal refers to the process of visiting all the vertices (and optionally all the edges) in a graph. There are two primary strategies for doing this:

* **Depth-First Search (DFS)**
* **Breadth-First Search (BFS)**

We’ll assume **connected graphs** unless otherwise specified — meaning all nodes are reachable from any starting point. In a **disconnected graph**, some vertices may be isolated or form separate clusters not connected to the rest of the graph.

> 🖼️ **Example: Unconnected Graph**

![Unconnected graph](image-15.png)

In this example, there's no path from `A` to `K`, so the graph is considered **disconnected**.

---

## 🔍 Depth-First Search (DFS)

DFS explores a graph by going **as deep as possible** along each branch before backtracking. Think of it like exploring a maze by going forward until you hit a dead end, then backtracking to try a different route.

DFS is useful for:

* Finding **cycles**
* Detecting **connectivity**
* Solving **topological sorting**
* Exploring **components**

---

### 🔁 Recursive DFS (Standard)

* Start at any vertex.
* Recursively visit all **unvisited neighbors**.
* When no unvisited neighbors remain, **backtrack** to the previous vertex and continue.
* Mark vertices as **visited** to avoid reprocessing.
* End when all reachable vertices have been visited.

🔁 **Backtracking** is handled automatically by the **call stack** in recursion.

> ✅ Each vertex is marked “complete” once **all** its connected edges have been explored.

---

#### 🧠 Time Complexity

DFS runs in **O(V + E)** time, where:

* `V` = number of vertices
* `E` = number of edges

This is because:

* Each vertex is visited once
* Each edge is followed at most twice (once in each direction for undirected graphs)

---

### 🧱 Pseudocode (Recursive DFS)

```python
def dfs(v, visited):
    visited.add(v)
    for neighbor in v.neighbors():
        if neighbor not in visited:
            dfs(neighbor, visited)
```

* `v.neighbors()` returns all adjacent (outgoing) vertices.

---

### 💡 DFS on Disconnected Graphs

To fully traverse **disconnected graphs**, you must call DFS for **each unvisited vertex**:

```python
for v in graph.vertices():
    if v not in visited:
        dfs(v, visited)
```

---

### 📥 Iterative DFS

Instead of recursion, we can simulate the call stack using an explicit **stack** (LIFO structure):

1. Start by pushing a vertex onto the stack.
2. Pop from the stack, visit the vertex, and push its **unvisited neighbors**.
3. Repeat until the stack is empty.

This mimics the recursive process.

> ❗ The stack holds **discovered** vertices waiting to be processed, not fully visited ones.

👨‍💻 Time complexity: Still **O(V + E)**

---

## 🌐 Breadth-First Search (BFS)

BFS explores a graph **level by level**, starting from a source vertex. It visits all immediate neighbors before moving deeper.

This makes BFS ideal for:

* Finding **shortest paths** in unweighted graphs
* Exploring **layered structures** (e.g. social networks, games)
* Checking **connectivity**

---

### 🚶 Algorithm (BFS)

BFS uses a **queue** (FIFO structure):

1. Enqueue a starting vertex.
2. While the queue isn't empty:

   * Dequeue a vertex.
   * Visit and enqueue all **unvisited neighbors**.

Each vertex is **visited once**, and neighbors are queued only once.

---

### 🌊 Layered Traversal

BFS processes vertices in "waves" or **layers**.

> All vertices at distance 1 from the start are visited before any at distance 2, and so on.

![Example of BFS layers](image-16.png)

* Within each layer, the **order doesn't matter**.
* The key idea is that BFS finds the **minimum number of hops** from the start vertex to any other.

---

### 🧱 Pseudocode (BFS)

```python
from collections import deque

def bfs(start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    
    while queue:
        v = queue.popleft()
        for neighbor in v.neighbors():
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

---

## ⚖️ DFS vs BFS: Summary

| Feature                  | DFS                           | BFS                          |
| ------------------------ | ----------------------------- | ---------------------------- |
| Uses                     | Stack (recursive or explicit) | Queue (FIFO)                 |
| Exploration style        | Deep first                    | Wide (layered)               |
| Finds shortest path      | ❌ Not guaranteed              | ✅ Yes (in unweighted graphs) |
| Detects cycles           | ✅ Yes                         | ⚠️ Less common use case      |
| Space usage (worst case) | O(V)                          | O(V)                         |
| Time complexity          | O(V + E)                      | O(V + E)                     |

> 🔁 The only major difference in implementation is the **data structure** used for storing vertices to be processed.