# 🚀 7.3 Dijkstra’s Algorithm

Dijkstra’s algorithm finds the **shortest paths** from a source vertex to all other vertices in a **weighted graph** with **non-negative edge weights**.

It’s widely used in:

* Network routing (e.g. finding the fastest route across a network)
* Motion planning in robotics
* GPS and pathfinding in games

> ⚠️ Dijkstra's algorithm **does not work correctly** if the graph contains **negative-weight edges**. For such graphs, use **Bellman-Ford**, which is less efficient but handles negative weights.

---

## 🎥 7.3.1 Video Overview Summary

The algorithm starts from a **source vertex** and gradually builds a “**cloud**” of vertices whose shortest paths have been determined.

At each step:

* A new vertex is added to the cloud — the one with the current **smallest known distance**.
* The algorithm **relaxes** the edges from that vertex, updating the distances to neighboring vertices if a shorter path is found through it.
* This process repeats until all vertices have been processed.

---

## 🔧 Core Concepts

### 🌩️ The Cloud

* Represents all vertices for which the shortest path is **finalized**.
* Grows **greedily** by adding the vertex with the **lowest tentative distance** at each step.

### 🔄 Edge Relaxation

Edge relaxation checks if a known path to a neighbor can be **improved** by going through a newly added vertex:

If:
`dist[u] + weight(u, v) < dist[v]`
Then:
`dist[v] = dist[u] + weight(u, v)`

This can even **overwrite previous shortest paths**, as we may find a better route via another vertex.

---

## 🧠 Dijkstra’s Algorithm: Step-by-Step

1. **Initialize distances**:

   * Create a `dist` array or dictionary, initialized to `∞` (infinity).
   * Set `dist[source] = 0`.

2. **Priority queue (min-heap)**:

   * Stores tuples `(distance, vertex)`, prioritizing **smaller distance**.
   * Ensures we always pick the next closest vertex.

3. **Main loop**:

   * While the queue isn’t empty:

     1. Pop the vertex `u` with the **smallest `dist[u]`**.
     2. For each neighbor `v` of `u`:

        * If the path through `u` is shorter:

          * Update `dist[v]`
          * Push `(dist[v], v)` into the queue
     3. Optionally mark `u` as **visited** to skip revisiting (especially important in basic or unsorted implementations).

4. When complete, `dist[v]` gives the shortest distance from the source to `v`.

---

## 🧮 Time Complexity

Depends on the data structure used for the priority queue:

| Implementation Type           | Time Complexity                |
| ----------------------------- | ------------------------------ |
| Using **binary heap**         | `O((V + E) log V)`             |
| Using **unsorted list/array** | `O(V^2)`                       |
| Using **Fibonacci heap**      | `O(E + V log V)` (theoretical) |

> * `V` = number of vertices
> * `E` = number of edges
> * The heap-based implementation is most commonly used in practice.

---

## ✅ Recap

* Efficient for **non-negative** weights.
* Uses a **greedy approach** with a **min-priority queue**.
* Finds **single-source shortest paths** efficiently.
* Does **not** work with negative weights — use **Bellman-Ford** for those cases.