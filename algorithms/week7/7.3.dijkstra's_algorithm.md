# 7.3 Dijkstra's algorithm

Allows you to find shortest path in a **weighted** graph. It utilises a priority queue to ensure that the vertices are processed in an efficient order.

It's uses range from optimising data transfer and for motion planning in robotics.

It only works with non negative weights. In a case where you have negative edges it is correct to use bellman ford algorithm.

You wouldn't use Bellman Ford for all cases as it is less efficient.
---

## 7.3.1 Video Overview

Dijksta's algorithm starts from a vertex and forms an ever growing 'cloud'. The cloud contains the vertices that have their shortest path figured out.

Every stage the vertices connected to the cloud get added until the whole set has its shortest path figured out.

### Edge Relaxation

When we add a new vertex to the cloud we check all neighbours of that vertex to see if the path going through the new vertex is shorter. This also affects vertices already in the cloud and may rewrite their shortest path.

### Algorithm

At **initialization**, we keep an **array** (or dictionary) called `dist` that holds the **shortest known distance** from the source vertex to every other vertex. Each element is set to **infinity** (`∞`), except for the **source** vertex, which is set to `0`.

We can use an array if the vertices are **indexed** from `0` to `n - 1`. Otherwise, we can use a **map/dictionary**.

We also create a **priority queue** (typically a **min-heap**) that stores `(distance, vertex)` pairs. The **priority** is the current shortest known distance — this ensures we always pick the **closest unvisited vertex** next.

The main **loop** of the algorithm runs until the priority queue is empty. At each step:

1. Pop the vertex with the **smallest distance**.
2. For each **neighbor** of that vertex:

   * If the new path through this vertex is **shorter**, update the `dist` array.
   * Push the updated `(distance, neighbor)` into the priority queue.
3. Optionally, mark the current vertex as **visited** to avoid revisiting it.

Once the queue is empty, the `dist` array contains the **shortest distances** from the source to all other vertices.

### Time Complexity

Priority queue and edge relaxation step keep the process efficient

Overall O((v+e)logv)