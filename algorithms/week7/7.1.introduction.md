# 📌 Introduction to Graphs

Graphs are a powerful and flexible data structure used to model **relationships** between objects. They consist of a set of **vertices** (also called **nodes**) and **edges** that connect them.

> Example applications:
>
> * Train networks
> * Social networks
> * Road maps
> * Webpage links
> * Dependency graphs in software

---

## 🧱 Basic Terminology

* **Vertex (plural: vertices)** = a node or point
* **Edge** = a connection or link between two vertices

### Empty Graph

A graph can be completely empty — with no nodes and no edges:

```
V = Ø
E = Ø
```

> `Ø` denotes the **empty set**.

---

### Isolated Vertices

A vertex can exist with **no connections** (no edges).
This is valid and useful in some contexts.

![A singular vertex K with no edges](image-1.png)

Example: A city on an island (represented by a vertex) with no road connections (edges) to other cities.

---

## 📊 Graph Density

### Dense Graph

A graph is **dense** when it has **many edges** — close to the **maximum number** possible for its vertex count.

* A **complete graph** is the densest possible: every node is connected to every other node.

![Complete Graph](image-2.png)

For a graph with `n` vertices, the maximum number of edges is:

* **Undirected**: `n(n-1)/2`
* **Directed**: `n(n-1)`

---

### Sparse Graph

A graph is **sparse** when it has **very few edges** relative to the number of vertices.

![Sparse graph](image-3.png)

Sparse graphs often appear in real-world scenarios (e.g., road networks — not every city is directly connected to every other).

---

## 🔄 Types of Graphs

### Undirected Graph

![Undirected graph](image-4.png)

* Edges have **no direction**
* If A is connected to B, B is connected to A
* Example: Facebook “friends” — mutual relationships

---

### Directed Graph (Digraph)

![Directed graph](image-5.png)

* Edges have **direction**
* If A points to B, it doesn't mean B points back
* Example: Twitter “followers” — one-way relationships

---

### Weighted Graph

![Weighted graph](image-6.png)

* Each edge carries a **weight** or **cost**
* Weights can represent:

  * Distance (road maps)
  * Time (flight durations)
  * Cost (network latency)
* Can be **directed or undirected**

**Triplet notation:** `(u, v, w)`

* `u` = source
* `v` = target
* `w` = weight

> Example:
> `(a, b, 3)` and `(b, a, 7)` → different weights in each direction.

✅ **Weights can be negative** in some contexts (e.g., financial gains/losses), but care must be taken when choosing algorithms.

---

## 🖥 Representing Graphs in Code

### 1. **Edge List**

Stores each edge as a triplet (or a pair if unweighted):

```python
edges = [(a, b, 5), (b, c, 2), (a, c, 9)]
```

* Minimal memory usage
* Searching for a specific edge is **slow (O(E))**
* Vertices without edges may not appear

---

### 2. **Adjacency Matrix**

A 2D array (`V x V`) that stores edge weights.

![Adjacency matrix example](image-8.png)

* Rows = source vertices
* Columns = destination vertices
* Value = weight (or 0/1 if unweighted)

#### Unconnected nodes:

* Use `∞` (positive or negative) or `0`, depending on the problem

  * `∞`: For shortest-path problems (Dijkstra, etc.)
  * `–∞`: For maximization problems (e.g., gain)

![Adjacency matrix with infinities](image-9.png)
![Unweighted adjacency matrix](image-10.png)

* **Symmetric** for undirected graphs

✅ **Fast edge lookups**: O(1)

❌ **Poor space efficiency** for sparse graphs

---

### 3. **Adjacency List**

Each vertex has a list of **outgoing edges**:

```python
{
  "A": [("B", 5), ("C", 9)],
  "B": [("C", 2)],
  ...
}
```

![Adjacency list](image-11.png)

* **Efficient for sparse graphs**
* Lookup for a specific edge = O(k) where k is number of neighbors
* Ideal when only some vertices are heavily connected

---

## ⚖️ Comparing Representations

| Feature               | **Edge List** | **Adjacency Matrix** | **Adjacency List** |
| --------------------- | ------------- | -------------------- | ------------------ |
| Space (Sparse Graphs) | ✅ Efficient   | ❌ Wasteful           | ✅ Efficient        |
| Space (Dense Graphs)  | ❌ Inefficient | ✅ Better             | ❌ Inefficient      |
| Edge Lookup Time      | ❌ O(E)        | ✅ O(1)               | ❌ O(k)             |
| Iterate All Edges     | ✅ O(E)        | ❌ O(V²)              | ✅ O(E)             |
| Add Vertex            | ❌ Costly      | ❌ Costly             | ✅ Easy             |
| Add Edge              | ✅ Simple      | ✅ Simple             | ✅ Simple           |

---

## 📌 Summary

* **Graphs** model relationships using nodes and edges.
* Can be **directed**, **undirected**, **weighted**, or **unweighted**.
* **Sparse** vs **dense** graphs affect which data structure to use:

  * **Adjacency List**: Best for sparse graphs
  * **Adjacency Matrix**: Best for dense graphs or when fast edge lookups are needed
  * **Edge List**: Compact but slow for edge lookups
* Understanding graph types and representations is essential for applying the right algorithms later (e.g., DFS, BFS, Dijkstra’s, etc.)