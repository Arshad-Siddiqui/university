# 🌲 Spanning Trees

A **spanning tree** is a **subgraph** of an **undirected graph** that:

* Includes **all the vertices**
* Is **connected**
* Contains **no cycles**

Essentially, it's the **minimum structure** required to connect all the nodes in the graph.

> If a graph has `n` vertices, a spanning tree will always have **exactly `n - 1` edges**.

### Why are spanning trees useful?

They reduce **redundancy** and **cost**. This is valuable in practical problems like:

* Designing efficient computer or electrical **networks**
* Laying out **transportation** routes
* Minimizing **infrastructure cost** while keeping full connectivity

---

## 🌟 Minimum Spanning Tree (MST)

A **Minimum Spanning Tree** is a spanning tree with the **lowest total edge weight** (sum of all edge weights).

> It ensures connectivity at **minimal cost**.

### MST Conditions

* The graph must be **connected** and **undirected**
* If all edge weights are **distinct**, the MST is **unique**

---

## ⚙️ Greedy Algorithms

Both major MST algorithms are **greedy**. That means they make **locally optimal choices** at each step in hopes of finding a globally optimal solution.

A greedy algorithm doesn’t backtrack or consider future implications — it simply picks the “best” available option at every moment.

---

## 🌐 Prim-Jarnik Algorithm

**Prim’s Algorithm** (also called Prim-Jarnik) is similar to **Dijkstra’s Algorithm**:

* It starts with **one vertex**
* It grows a **"cloud"** of connected vertices by repeatedly adding the **minimum-weight edge** that connects the cloud to a new vertex
* It ensures that the tree stays connected and acyclic

### How it works:

1. Start with an arbitrary vertex
2. Use a **priority queue** (min-heap) to track the **minimum-weight edge** from the current tree to a new vertex
3. At each step, add the **lowest-weight edge** that connects a vertex in the tree to one not in the tree

### Time complexity:

* With a binary heap: **O((n + m) log n)**

  * `n` = number of vertices
  * `m` = number of edges

---

## 🌲 Kruskal’s Algorithm

Kruskal’s algorithm takes a different approach:

* It starts with **no edges**
* It **sorts** all edges by weight
* It **adds** edges one by one (starting with the smallest), **as long as** they don't create a cycle
* This process builds a **forest** (disconnected trees) that eventually connects into a full MST

### Cycle detection

* Kruskal’s algorithm uses a **Disjoint Set (Union-Find)** data structure to efficiently check whether adding an edge will create a cycle

### Time complexity:

* Sorting edges: **O(m log m)**
* Union-Find operations: almost **O(1)** per edge with path compression

Overall: **O(m log n)**

---

## ✅ Choosing Between Them

| Algorithm     | Best for...                                                                      |
| ------------- | -------------------------------------------------------------------------------- |
| **Prim’s**    | Dense graphs (many edges), especially when using adjacency list + priority queue |
| **Kruskal’s** | Sparse graphs, or when edge list is already available                            |

---

## 🔍 Bonus Topics (Related Graph Problems)

* **Maximum Flow Problem**: Finding the maximum possible "flow" (like water or data) from a source to a sink in a network
* **Traveling Salesperson Problem (TSP)**: Finding the shortest possible route that visits all vertices exactly once and returns to the start — NP-hard
* **Graph Coloring**: Assigning colors to vertices so that no adjacent vertices share a color — used in scheduling, register allocation, etc.
