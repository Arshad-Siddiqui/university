# Reading 14.3 Graph Traversals (GT)

GT algorithms can be used to...

- Check **reachability** of vertices.
- Computing a path between vertices
- Finding the **shortest path** between vertices
- Check if a given graph is **connected**
- Checking for **cycles** or identifying if the graph is **acyclic**.

---

## 14.3.1 DFS

Uses include checking if a graph is connected or determining if a path exists between two vertices

It involves consistently moving to unvisited vertices until you reach a dead end. You then recursively backtrack until you can visit an unvisited vertex and progress down that path.

Once you make you way back because everything has been visited the algorithm is complete.

### DFS Tree

In order to find every vertex we might not visit every edge. The edges we do visit form a tree like structure called a DFS tree.

The edges that reach an vertex are either called a **discovery edge** or a **tree edge**.

The edges that take us to a previously visited vertex during execution are called **nontree edges**.

#### In the case of an undirected graph

**Back edges** are nontree edges that take you from a vertex to it's ancester in the DFS tree.

**Forward edges** connect a vertex to a descendant in the DFS tree.

**Cross edges** takes you to neither an ancestor nor descenant.

DFS is efficient for traversal. O(n + m) so it grows linearly in time complexity.

### Testing for connectivity

Compares length of discovered to the number of vertices. If they are the same then there is only 1 component to the graph.

## BFS

> Read the book. Everything here is going over your head. There's a cool section on BFS

BFS has similar running time at O(n + m)

BFS finding paths guarantees that they use as few edges as possible.

BFS can be used to check connectivity as well as DFS. Can also identify connected components or locate cycles.

For **digraphs** DFS is better suited for finding cycles and finding strongly connected components.