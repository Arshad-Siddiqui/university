# 📖 14.3 Graph Traversals (GT)

Graph traversal (GT) algorithms systematically explore all or part of a graph. They are fundamental tools in computer science and can be used to:

* 🔎 **Check reachability** of vertices
* 🧭 **Compute a path** between two vertices
* 🛣️ **Find the shortest path** (in unweighted graphs)
* 🧩 Determine if the graph is **connected**
* 🔁 Detect **cycles** or check for **acyclicity**

---

## 🔍 14.3.1 Depth-First Search (DFS)

DFS explores as far as possible along each branch before backtracking — ideal for deep traversal and cycle detection.

### ✅ Uses of DFS

* Check if a graph is **connected**
* Determine if a **path exists** between two vertices
* Detect **cycles**
* Explore **connected components**

---

### 🌲 DFS Tree

While performing DFS, the algorithm builds an implicit structure known as a **DFS tree** (or forest, in the case of disconnected graphs).

* **Tree (Discovery) edges**: edges that lead to **new** vertices — these form the DFS tree itself.
* **Non-tree edges**: edges that connect to a **previously visited** vertex.

Non-tree edges fall into categories:

#### 📎 Types of Non-tree Edges (undirected graphs)

* **Back edge**: connects a node to one of its **ancestors** in the DFS tree.
* **Forward edge**: connects a node to one of its **descendants** (but is not part of the DFS tree).
* **Cross edge**: connects nodes that are neither ancestor nor descendant — typically between different subtrees or disconnected parts.

> 💡 In undirected graphs, only **tree edges** and **back edges** are relevant — forward and cross edges are typically concepts applied in directed graphs.

---

### 🧪 Testing Connectivity with DFS

* Run DFS from an arbitrary vertex.
* Count the number of discovered vertices.
* If the number of discovered vertices equals the total number of vertices in the graph, the graph is **connected**.

📈 **Time complexity**:
DFS runs in **O(n + m)** time

* `n` = number of vertices
* `m` = number of edges
  This is optimal for traversal.

---

## 🌐 Breadth-First Search (BFS)

> *BFS is a great next step, but if it’s not clicking yet, go back and reread the section — it’s conceptually rich and worth understanding fully.*

### ✅ Uses of BFS

* Check if a graph is **connected**
* **Find shortest paths** (in terms of edge count)
* Identify **connected components**
* Detect **cycles**
* Explore **layers** (helpful in network analysis or level-order processing)

In contrast to DFS, BFS explores the graph in **layers** (i.e., it visits all vertices at distance `k` before moving to `k+1`).

> ⚠️ For **directed graphs (digraphs)**:

* DFS is generally better for:

  * Detecting **cycles**
  * Finding **strongly connected components**

### 🕒 Time Complexity

Like DFS, BFS also runs in **O(n + m)** time.