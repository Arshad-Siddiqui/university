# ðŸ“š Reading: Priority Queues

A **priority queue** is like a regular queue (FIFO: First-In-First-Out), but with a twist â€” each element is associated with a **priority** (a *key*), and **the element with the *lowest* key is removed first**, regardless of when it was added.

This makes them ideal for scheduling systems, simulations, and algorithms like **Dijkstra's shortest path** or **A\* search**.

---

## ðŸ§  Key Concept

Each element has:

* A **value** (the data you're storing)
* A **key** (its priority â€” must be comparable)

> In Python, any object can serve as a key, as long as it supports comparison operations (i.e., it implements `<`, `<=`, etc.).

If multiple elements have the same lowest key, **any of them may be removed**, usually arbitrarily.

---

## ðŸ› ï¸ Core Priority Queue Operations

| Operation      | Description                                                |
| -------------- | ---------------------------------------------------------- |
| `insert(k, v)` | Adds value `v` with priority key `k`                       |
| `min()`        | Returns (but does not remove) the item with the lowest key |
| `remove_min()` | Removes and returns the item with the lowest key           |

---

## ðŸ§ª Implementation Approaches

There are a few ways to implement priority queues, each with trade-offs in efficiency depending on use case.

---

### 1ï¸âƒ£ Unsorted List Implementation

Here, elements are stored in no particular order.

#### ðŸ”§ How it works:

* **Insertion**: Just append to the list â€” `O(1)`
* **Finding minimum**: Linear search for lowest key â€” `O(n)`
* **Removing minimum**: Also `O(n)` (since you first have to find it)

#### âœ… Pros:

* Super fast insertion
* Good if you rarely remove or inspect the minimum

#### âŒ Cons:

* Slow when you frequently need the min element

---

### 2ï¸âƒ£ Sorted List Implementation

Here, elements are kept sorted by their keys at all times (e.g., ascending order).

#### ðŸ”§ How it works:

* **Insertion**: Must place element in correct spot â€” `O(n)` (in the worst case you scan the whole list)
* **Finding minimum**: Always at the front â€” `O(1)`
* **Removing minimum**: Also at the front â€” `O(1)`

#### âœ… Pros:

* Fast access and removal of min item
* Ideal if you're frequently removing or inspecting the minimum

#### âŒ Cons:

* Insertion is slow (you must preserve order)

---

## ðŸ§© Choosing Between the Two

| Use Case                               | Recommended Approach |
| -------------------------------------- | -------------------- |
| Many inserts, few removals             | **Unsorted List**    |
| Frequent `min()` or `remove_min()` ops | **Sorted List**      |

---

## âš™ï¸ Real-world Implementation Notes

Pythonâ€™s `heapq` module provides an efficient **binary heap**-based implementation of a priority queue (a third and better alternative). It offers:

* Insert: `O(log n)`
* Remove min: `O(log n)`
* Find min: `O(1)`

> A binary heap combines the best of both worlds and is the most common structure for priority queues in practice.

Great! Let's walk through a full explanation of **heap-based implementations of priority queues**, focusing on **binary heaps**, which are the standard for efficient priority queue behavior.

---

# âš™ï¸ Priority Queues Using Heaps

## ðŸ”º Binary Heap Overview

A **binary heap** is a complete binary tree where each node satisfies the **heap-order property**:

* In a **min-heap**, the key at each node is **less than or equal to** the keys of its children.
* This guarantees that the **minimum key is always at the root** of the tree.

> A max-heap is the opposite (useful if you want highest-priority first), but weâ€™re focusing on min-heaps here.

---

## ðŸ§± Binary Heap as an Array

Although a binary heap is conceptually a tree, itâ€™s stored as an **array** (or Python list) because:

* Itâ€™s a **complete binary tree**: no gaps, perfectly filled from top to bottom, left to right.
* Children and parent relationships are calculated via index math:

| Node        | Index Formula  |
| ----------- | -------------- |
| Left child  | `2i + 1`       |
| Right child | `2i + 2`       |
| Parent      | `(i - 1) // 2` |

This structure saves space and allows for very fast access and manipulation.

---

## ðŸ”§ Key Heap Operations

### âœ… `insert(k, v)` â†’ `O(log n)`

* Add the new element at the **end of the array**.
* **Upheap (bubble up)**: Compare the new elementâ€™s key with its parent and swap if necessary, continuing up until heap property is restored.

### âœ… `min()` â†’ `O(1)`

* The **smallest key** is always at index 0 (the root).

### âœ… `remove_min()` â†’ `O(log n)`

* Remove the root element (min).
* Move the **last element** to the root to fill the hole.
* **Downheap (bubble down)**: Compare with children and swap with the smaller child until the heap property is restored.

---

## âœ¨ Pythonâ€™s `heapq` Module

Pythonâ€™s standard library provides a module called `heapq` that uses a **min-heap** under the hood.

### ðŸ“¦ Basic Usage

```python
import heapq

pq = []
heapq.heappush(pq, (5, 'task A'))  # (priority, value)
heapq.heappush(pq, (2, 'task B'))
heapq.heappush(pq, (7, 'task C'))

print(heapq.heappop(pq))  # (2, 'task B') -- lowest priority comes out first
```

> Notice we store `(key, value)` pairs so that heapq uses the key for comparison but retains the value.

---

## ðŸ” Custom Priorities

If your data isnâ€™t naturally comparable, or you want custom orderings (e.g., based on object attributes), you can use `dataclasses` or tuples:

```python
from dataclasses import dataclass, field

@dataclass(order=True)
class Task:
    priority: int
    description: str = field(compare=False)

pq = []
heapq.heappush(pq, Task(3, "Write report"))
heapq.heappush(pq, Task(1, "Fix bug"))
heapq.heappush(pq, Task(2, "Review PR"))

print(heapq.heappop(pq))  # Task(priority=1, description='Fix bug')
```

---

## ðŸ Summary of Implementations

| Approach        | Insert     | Min Lookup | Remove Min |
| --------------- | ---------- | ---------- | ---------- |
| Unsorted List   | `O(1)`     | `O(n)`     | `O(n)`     |
| Sorted List     | `O(n)`     | `O(1)`     | `O(1)`     |
| **Binary Heap** | `O(log n)` | `O(1)`     | `O(log n)` |

> Binary heaps provide the **best overall tradeoff** â€” fast insertions and fast removals â€” and are the go-to structure for real-world priority queues.

---

Would you like a Python implementation of a **priority queue class using a heap**?
