# 📚 Reading: Priority Queues

A **priority queue** is like a regular queue (FIFO: First-In-First-Out), but with a twist — each element is associated with a **priority** (a *key*), and **the element with the *lowest* key is removed first**, regardless of when it was added.

This makes them ideal for scheduling systems, simulations, and algorithms like **Dijkstra's shortest path** or **A\* search**.

---

## 🧠 Key Concept

Each element has:

* A **value** (the data you're storing)
* A **key** (its priority — must be comparable)

> In Python, any object can serve as a key, as long as it supports comparison operations (i.e., it implements `<`, `<=`, etc.).

If multiple elements have the same lowest key, **any of them may be removed**, usually arbitrarily.

---

## 🛠️ Core Priority Queue Operations

| Operation      | Description                                                |
| -------------- | ---------------------------------------------------------- |
| `insert(k, v)` | Adds value `v` with priority key `k`                       |
| `min()`        | Returns (but does not remove) the item with the lowest key |
| `remove_min()` | Removes and returns the item with the lowest key           |

---

## 🧪 Implementation Approaches

There are a few ways to implement priority queues, each with trade-offs in efficiency depending on use case.

---

### 1️⃣ Unsorted List Implementation

Here, elements are stored in no particular order.

#### 🔧 How it works:

* **Insertion**: Just append to the list — `O(1)`
* **Finding minimum**: Linear search for lowest key — `O(n)`
* **Removing minimum**: Also `O(n)` (since you first have to find it)

#### ✅ Pros:

* Super fast insertion
* Good if you rarely remove or inspect the minimum

#### ❌ Cons:

* Slow when you frequently need the min element

---

### 2️⃣ Sorted List Implementation

Here, elements are kept sorted by their keys at all times (e.g., ascending order).

#### 🔧 How it works:

* **Insertion**: Must place element in correct spot — `O(n)` (in the worst case you scan the whole list)
* **Finding minimum**: Always at the front — `O(1)`
* **Removing minimum**: Also at the front — `O(1)`

#### ✅ Pros:

* Fast access and removal of min item
* Ideal if you're frequently removing or inspecting the minimum

#### ❌ Cons:

* Insertion is slow (you must preserve order)

---

## 🧩 Choosing Between the Two

| Use Case                               | Recommended Approach |
| -------------------------------------- | -------------------- |
| Many inserts, few removals             | **Unsorted List**    |
| Frequent `min()` or `remove_min()` ops | **Sorted List**      |

---

## ⚙️ Real-world Implementation Notes

Python’s `heapq` module provides an efficient **binary heap**-based implementation of a priority queue (a third and better alternative). It offers:

* Insert: `O(log n)`
* Remove min: `O(log n)`
* Find min: `O(1)`

> A binary heap combines the best of both worlds and is the most common structure for priority queues in practice.

Great! Let's walk through a full explanation of **heap-based implementations of priority queues**, focusing on **binary heaps**, which are the standard for efficient priority queue behavior.

---

# ⚙️ Priority Queues Using Heaps

## 🔺 Binary Heap Overview

A **binary heap** is a complete binary tree where each node satisfies the **heap-order property**:

* In a **min-heap**, the key at each node is **less than or equal to** the keys of its children.
* This guarantees that the **minimum key is always at the root** of the tree.

> A max-heap is the opposite (useful if you want highest-priority first), but we’re focusing on min-heaps here.

---

## 🧱 Binary Heap as an Array

Although a binary heap is conceptually a tree, it’s stored as an **array** (or Python list) because:

* It’s a **complete binary tree**: no gaps, perfectly filled from top to bottom, left to right.
* Children and parent relationships are calculated via index math:

| Node        | Index Formula  |
| ----------- | -------------- |
| Left child  | `2i + 1`       |
| Right child | `2i + 2`       |
| Parent      | `(i - 1) // 2` |

This structure saves space and allows for very fast access and manipulation.

---

## 🔧 Key Heap Operations

### ✅ `insert(k, v)` → `O(log n)`

* Add the new element at the **end of the array**.
* **Upheap (bubble up)**: Compare the new element’s key with its parent and swap if necessary, continuing up until heap property is restored.

### ✅ `min()` → `O(1)`

* The **smallest key** is always at index 0 (the root).

### ✅ `remove_min()` → `O(log n)`

* Remove the root element (min).
* Move the **last element** to the root to fill the hole.
* **Downheap (bubble down)**: Compare with children and swap with the smaller child until the heap property is restored.

---

## ✨ Python’s `heapq` Module

Python’s standard library provides a module called `heapq` that uses a **min-heap** under the hood.

### 📦 Basic Usage

```python
import heapq

pq = []
heapq.heappush(pq, (5, 'task A'))  # (priority, value)
heapq.heappush(pq, (2, 'task B'))
heapq.heappush(pq, (7, 'task C'))

print(heapq.heappop(pq))  # (2, 'task B') -- lowest priority comes out first
```

> Notice we store `(key, value)` pairs so that heapq uses the key for comparison but retains the value.

---

## 🔁 Custom Priorities

If your data isn’t naturally comparable, or you want custom orderings (e.g., based on object attributes), you can use `dataclasses` or tuples:

```python
from dataclasses import dataclass, field

@dataclass(order=True)
class Task:
    priority: int
    description: str = field(compare=False)

pq = []
heapq.heappush(pq, Task(3, "Write report"))
heapq.heappush(pq, Task(1, "Fix bug"))
heapq.heappush(pq, Task(2, "Review PR"))

print(heapq.heappop(pq))  # Task(priority=1, description='Fix bug')
```

---

## 🏁 Summary of Implementations

| Approach        | Insert     | Min Lookup | Remove Min |
| --------------- | ---------- | ---------- | ---------- |
| Unsorted List   | `O(1)`     | `O(n)`     | `O(n)`     |
| Sorted List     | `O(n)`     | `O(1)`     | `O(1)`     |
| **Binary Heap** | `O(log n)` | `O(1)`     | `O(log n)` |

> Binary heaps provide the **best overall tradeoff** — fast insertions and fast removals — and are the go-to structure for real-world priority queues.

---

Would you like a Python implementation of a **priority queue class using a heap**?
