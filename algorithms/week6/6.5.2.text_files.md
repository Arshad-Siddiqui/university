# Working with Text Files

Text files are great to use as data storage. This is because humans can read them and programs can read/write as well.

Great for databases logs etc.

## text file formats

- Plain text .txt
- Comma-separated values .csv
can represent tables
- .json can be used for web data exchange
- xml

## pros

- Readabable
- platform independent
- Widespread language support

## cons

- Aren't structured/organised.
- Not efficient for large datasets.

## Text file encoding

UTF-8 is the default for most

ASCII: Simple encoding that covers basic english and numbers.

## Handling Text Files in Python

'with' is an important keyword that automatically opens and closes a file ensuring no data leaks

```py

# Opens somefile.txt in 'r'ead mode.
with open('somefile.txt', 'r') as file:
  for data in file:
    print(data)
# After the with block the file is automatically closed.
```

Notice how above we're looping through 'data' in 'file'. In this case data refers to each line in the file so looping through it and printing prints the entire file.

Calling 'open' without specifying encoding it just uses default encoding. Usually this is utf-8.

However if you're working with others the default encoding could be different per machine so that could be a source of error.

```py
with open('some_cool_file.txt', 'r', encoding='utf-8'):
```

By specifing encoding we make the code more portable as it runs on more machines.

## Closing file

If we don't open the file in a 'with' block then we need to manually close the file.

It's best to check that the file exists using try statement
```py

file = None
try:
  # open file

finally:  
  if file is not None:
    file.close()
```
> Above is some cute guff but it is way better to use with as you simplify the code and ensure you don't accidentally keep a file open.

## Writing to a file

When doing a 'with open' you do it in 'w'rite mode.

```py
with open('log.txt', 'w', encoding='utf-8') as file:
  file.write(data_to_be_written)
  
  # Ensures operation happens without delay. Although 'flushing' occurs when you close the file.
  file.flush()
```

If the file doesn't exist when you call the file with open then it gets created. It **also erases** the previous file if that exists.

To keep previous content you need to enter 'a'ppend mode

```py
with open('output.txt', 'a', encoding='utf-8') as file:
  file.write("new line that doesn't replace what came before")
```