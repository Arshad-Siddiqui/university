# 🧯 Error Handling in Python

Rather than letting your program crash when something goes wrong, it's often **better to handle errors explicitly**.

This is especially useful in:

* Web applications
* User-facing tools
* Scripts that must run reliably

---

## 🧪 Basic Try/Except Block

Use `try` and `except` to **catch exceptions**:

```py
try:
    risky_code()
except:
    print("Something went wrong!")
```

However, **you should avoid using a bare `except:`**, because it catches *all* exceptions—including ones you might not want to suppress (e.g., `KeyboardInterrupt`, `SystemExit`).

---

## 🎯 Handling Specific Exceptions

Catch specific errors to handle them more cleanly and predictably:

```py
try:
    result = 10 / 0
except ZeroDivisionError:
    print("You messed up homie. Divide by zero is haram.")
```

You can also catch **multiple errors with the same response**:

```py
except (SomeErrorOne, SomeErrorTwo):
    print("You hit one of the above errors.")
```

More specific exception types improve debugging and code clarity.

---

## `else` and `finally` Blocks

```py
try:
    process_data()
except ValueError:
    print("Wrong type of data, buddy.")
else:
    print("All good—let's get some work done.")
finally:
    print("This message always prints.")
```

* **`else`**: Runs *only if no error* occurs
* **`finally`**: Runs *no matter what*, great for cleanup (e.g., closing files)

---

## 🔧 Raising Custom Errors

You can define and raise your own exception types:

```py
class SomeCoolError(Exception):
    pass

raise SomeCoolError("This is a custom error.")
```

This lets you describe domain-specific problems (e.g., `InvalidUserInputError`, `InsufficientBalanceError`, etc.).

---

### 📑 Documenting Raised Exceptions

When writing a function that may raise an error, **document it**:

```py
def somefunc(param1, param2):
    """
    Description of the function.

    Args:
        param1: Description
        param2: Description

    Raises:
        SomeCoolError: If some specific condition is violated.
    """
```

Good documentation helps other developers (and your future self) understand what might go wrong and how to handle it.

---

## 🧘‍♂️ Responsibility of Functions

> 💡 **Your job is usually to raise meaningful exceptions—not to handle them.**

Let the calling code decide what to do. This keeps your functions clean, predictable, and reusable in different contexts.

---

### ✅ Summary

| Feature            | Purpose                              |
| ------------------ | ------------------------------------ |
| `try` / `except`   | Catch and handle errors              |
| `except TypeError` | Catch specific errors                |
| `except (A, B)`    | Handle multiple exceptions similarly |
| `else`             | Runs if no exceptions                |
| `finally`          | Always runs, great for cleanup       |
| `raise`            | Manually raise an exception          |
| Custom exceptions  | Define your own error types          |

---

Would you like a cheat sheet or template for structuring `try-except` logic or custom exception classes?
