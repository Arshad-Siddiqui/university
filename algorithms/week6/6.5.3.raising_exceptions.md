# Raising Exceptions

Raising errors can:

**Make the code more clear** and readable. You can just raise an error if something is incorrect and handle errors in a diferent piece of code. This improves code organisation.

Code becomes easier to understand and self-explanatory.

**Increases robutness** as the program doesn't just crash and keeps going regardless of errors.

**Helps with debugging** as raising errors give good details such as error type, where it happened and in which part of the stack frame.

It's really good for pinpointing the error location.

## When a function should raise an error

**Unrecoverable error**: When there's basically no way for your function to recover from something.

**Invalid inputs**: When function precondition is not met.

**Boundary conditions**: When they're exceeded should also raise an error. Such as when the user tries finding the square root of a negative number.

## Best practice

Raise the most specific exception. Don't just use a bare exception.

Provide clear messages with the exception explainin what went wrong and if possible how to resolve the issue.

Use finally block to ensure processes close properly.

## Alternative

Can return tuple containing a string that describes the error. Kinda like what golang does.

One problem with this is that it is easy to ignore errors leading to silent errors.

You're also returning 2 values which needs to be unpacked regardless of if there was an error or not.

```py
def my_func():
  return value, error_string
```

Another alternative is by **logging** the error using the pre-existing module of the same name.

```py
logging.error("You did bad btw")
```

Same bad things as above however. You can overlook the errors in the log as the program still runs.

## Assertion errors

Uses 'assert' keyword.

Really good for quickly debugging and checking stuff in development code.

However it is unsuitable for production as it just crashes the program.