# âœ… Raising Exceptions in Python

Raising exceptions helps make your code:

### ğŸ§¼ 1. **Clearer and more readable**

Instead of cluttering your logic with `if`/`else` checks, you can **raise an error** when something goes wrong and handle it elsewhere. This keeps your logic clean and modular.

### ğŸ’ª 2. **More robust**

Rather than letting your program **crash silently** or continue with invalid data, exceptions allow you to **halt execution cleanly** or **redirect flow** for safe recovery.

### ğŸ” 3. **Easier to debug**

Exceptions give you:

* A specific error **type**
* A **message**
* A **stack trace** pointing to **where** the problem occurred

This makes them invaluable for identifying and fixing bugs.

---

## ğŸš« When to Raise an Exception

Raise an exception if:

### âŒ 1. **The error is unrecoverable**

If your function cannot safely continue (e.g., failed to open a required file), raise an exception.

### ğŸ§ª 2. **Inputs are invalid**

If function **preconditions** (like type, range, or format of input) arenâ€™t met, raise a relevant exception.

### ğŸ“‰ 3. **Boundary conditions are violated**

For example, asking to calculate the square root of a negative number, or divide by zero.

---

## ğŸ§  Best Practices for Raising Exceptions

âœ… **Raise the most specific exception possible**
Avoid generic `Exception`. Use built-ins like `ValueError`, `TypeError`, `IndexError`, or define your own if needed.

âœ… **Add a clear error message**
Explain:

* What went wrong
* (Optionally) How to fix it

```py
raise ValueError("Input must be a positive integer")
```

âœ… **Use `finally` blocks wisely**
To ensure cleanup happens (e.g., closing files or releasing locks), even when an error occurs.

```py
try:
    file = open("data.txt")
    # process file
finally:
    file.close()
```

---

## âš–ï¸ Alternatives to Raising Exceptions

### 1. **Return (value, error message)** tuple

Popular in languages like Go:

```py
def my_func():
    return result, "error message if any"
```

ğŸ§¨ **Problems**:

* Easy to ignore errors
* Must **always unpack two values**
* No traceback or automatic propagation

### 2. **Use logging**

```py
import logging
logging.error("An error occurred")
```

ğŸ§¨ **Drawbacks**:

* Program keeps running
* Easy to overlook logged errors
* No traceback unless combined with exception

---

## ğŸ” Using `assert` for Debugging

```py
assert condition, "This should never be false"
```

âœ… Great for **internal checks** during development
âŒ Not suitable for production:

* `assert` statements can be **disabled** with the `-O` flag
* Cause the program to **crash abruptly** without custom handling

---

## Summary

| Approach               | Good for                           | Drawbacks                          |
| ---------------------- | ---------------------------------- | ---------------------------------- |
| Raising Exceptions     | Robust, clear, debug-friendly code | Requires structured error handling |
| Returning error tuples | Explicit handling like in Go       | Easy to ignore, awkward unpacking  |
| Logging                | Background monitoring              | Can be silently ignored            |
| Assert statements      | Quick sanity checks during dev     | Crashes, not for production use    |