# Insertion Sort

## Steps

1. Initialise: Start from second element
2. Compare: It with the element on the left.
3. Swap: If it's larger than the left number then swap.
4. Keep moving left: and compare until the position is found or you reach the beginning of the sequence.
5. Repeat: for every element.

**Variable speed** depending on how close to sorted it is.

## Best Case (already sorted)

Best case scenario has it taking **n-1 comparisons** where n refers to number of elements sorted. In other words if there are 10 elements already sorted then it only requires 9 comparisons.

O(n)

## Worse Case

The case where you require the **maximum** number of shifts/comparisons

> The worst case in insertion sort happens when the list is sorted in reverse order. Each new element added to the sorted portion of the list must be compared with **all previous elements** and shifted all the way to the beginning.

So:

* The 2nd element (index 1) makes **1** comparison
* The 3rd element (index 2) makes **2** comparisons
* The 4th element (index 3) makes **3** comparisons
* ...
* The nth element (index n-1) makes **n-1** comparisons

Add all these up:

$$
\text{Total comparisons} = 1 + 2 + 3 + \dots + (n-1)
= \frac{(n-1) \cdot n}{2}
$$

That‚Äôs a **triangular number**, which grows in **O(n¬≤)** time.

---

### üí° Simple Analogy

> Each new card you insert has to "fight" its way to the front by passing every earlier card ‚Äî and in the worst case, it passes **all** of them.

---

### üîÅ Summary

* Each element takes steps equal to its index
* Total steps = sum of 1 through n‚àí1 = `n(n‚àí1)/2`
* This leads to **O(n¬≤)** worst-case time

Worse case scenario is usually used to compare different algorithms efficiency.

---

## Why it is important to consider the efficiency of an algorithm when developing software for real-time systems such as air traffic control.

Real time systems such as air traffic controls need immediate responses for safety and accuracy.

Having an efficient algorithm means it can work through data quickly and provide responses timely.

Also important to have a **consistent** algorithm. An algorithm that might hang could cause errors.

## How the efficiency of an algorithm impacts the scalability of the software application

Efficiency directly affects scalability. As the dataset gets larger the inefficiencies stack up and become more and more noticeable.

For example there are very efficient algorithms that will run the same speed regardless of dataset size mostly. There are also very inefficient algorithms that exponentially take longer to execute with larger data pool.

Insertion sort is the type of algorithm that gets exponentially slow and doesn't scale well. It's still good in cases where there is a small dataset or you're adjusting an almost sorted dataset.